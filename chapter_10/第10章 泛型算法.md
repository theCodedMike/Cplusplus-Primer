# 第10章 泛型算法
## 10.1 概述

## 10.2 初识泛型算法
### 10.2.1 只读算法
### 10.2.2 写容器元素的算法
### 10.2.3 重排容器元素的算法

## 10.3 定制操作
### 10.3.1 向算法传递函数
### 10.3.2 lambda表达式
lambda表达式: `[capture list] (parameter list) -> return type { function body}`

lambda表达式中可以忽略参数列表和返回类型，但必须包含捕获列表和函数体。

lambda不能有默认参数。

lambda只有在其捕获列表中捕获一个它所在函数中的局部变量，才能在其函数体中使用该变量。

捕获列表只用于局部非static变量，lambda可以直接使用局部static变量。

### 10.3.3 lambda捕获和返回
混合使用隐式捕获和显式捕获时，显式捕获的变量必须使用与隐式捕获不同的方式。

<table>
    <tr>
        <th colspan="2">表10.1 lambda捕获列表</th>
    </tr>
    <tr>
        <td>[]</td> <td>空捕获列表</td>
    </tr>
    <tr>
        <td>var1, var2, ...</td> <td>显式捕获，值捕获</td>
    </tr>
    <tr>
        <td>&var1, &var2, ...</td> <td>显式捕获，引用捕获</td>
    </tr>
    <tr>
        <td>[=]</td> <td>隐式捕获，值捕获</td>
    </tr>
    <tr>
        <td>[&]</td> <td>隐式捕获，引用捕获</td>
    </tr>
    <tr>
        <td>[=, &var1, &var2, ...]</td> <td>混合捕获</td>
    </tr>
    <tr>
        <td>[&, var1, var2, ...]</td> <td>混合捕获</td>
    </tr>
</table>

### 10.3.4 参数绑定
标准库bind函数可以被视为一个通用的函数适配器，它接受一个可调用对象，生成一个新的可调用对象。


`auto new_callable = bind(callable, arg_list);`


## 10.4 再探迭代器
- 插入迭代器(insert iterator): 被绑定到一个容器上，可用来向容器插入元素
- 流迭代器(stream iterator): 被绑定到输入或输出流上，可用来遍历所关联的IO流
- 反向迭代器(reverse iterator): 被绑定到一个容器上，可用来遍历容器的逆向序列。forward_list没有反向迭代器
- 移动迭代器(move iterator):
### 10.4.1 插入迭代器
<table>
    <tr>
        <th colspan="2">表10.2 插入迭代器操作</th>
    </tr>
    <tr>
        <td>it = t</td> <td>在it指定的当前位置插入值t</td>
    </tr>
    <tr>
        <td>*it、++it、it++</td> <td></td>
    </tr>
</table>

插入迭代器有3种类型，差异在于元素插入的位置：
- back_inserter: 创建一个使用push_back的迭代器
- front_inserter: 创建一个使用push_front的迭代器
- inserter: 创建一个使用insert的迭代器

### 10.4.2 iostream迭代器
<table>
    <tr>
        <th colspan="2">表10.3 istream_iterator操作</th>
    </tr>
    <tr>
        <td>istream_iterator<> in(is);</td> <td>in从输入流is中读取类型为T的值</td>
    </tr>
    <tr>
        <td>istream_iterator<> end;</td> <td>尾后迭代器</td>
    </tr>
    <tr>
        <td>in1 == in2</td> <td>in1和in2必须读取相同的类型；如果二者都为尾后迭代器或绑定到相同的输入，则二者相等</td>
    </tr>
    <tr>
        <td>in1 != in2</td> <td></td>
    </tr>
    <tr>
        <td>*in</td> <td></td>
    </tr>
    <tr>
        <td>in->mem</td> <td>与(*in).eme等价</td>
    </tr>
    <tr>
        <td>++in, in++</td> <td></td>
    </tr>
</table>

<table>
    <tr>
        <th colspan="2">表10.4 ostream_iterator操作</th>
    </tr>
    <tr>
        <td>ostream_iterator<> out(os);</td> <td>out将类型为T的值写入到输出流os中</td>
    </tr>
    <tr>
        <td>ostream_iterator<> out(os, d);</td> <td>out将类型为T的值写入到输出流os中，每个值后面都输出一个d。d指向一个空字符结尾的字符数组</td>
    </tr>
    <tr>
        <td>out = val</td> <td>用输出运算符将val写入到out所绑定的ostream中。val的类型必须与out可写的类型兼容</td>
    </tr>
    <tr>
        <td>*out、++out、out++</td> <td>这些运算符不对out做任何事</td>
    </tr>
</table>

### 10.4.3 反向迭代器

## 10.5 泛型算法结构
<table>
    <tr>
        <th colspan="3">表10.5 迭代器类别</th>
    </tr>
    <tr>
        <td>1</td> <td>输入迭代器</td> <td>只读、不写；单遍扫描，只能递增</td>
    </tr>
    <tr>
        <td>2</td> <td>输出迭代器</td> <td>只写、不读；单遍扫描，只能递增</td>
    </tr>
    <tr>
        <td>3</td> <td>前向迭代器</td> <td>可读写；多遍扫描，只能递增</td>
    </tr>
    <tr>
        <td>4</td> <td>双向迭代器</td> <td>可读写；多遍扫描，可递增递减</td>
    </tr>
    <tr>
        <td>5</td> <td>随机访问迭代器</td> <td>可读写；多遍扫描，支持全部迭代器运算</td>
    </tr>
</table>

### 10.5.1 5类迭代器
**输入迭代器(input iterator)**: 可以读取序列中的元素。一个输入迭代器必须支持
- 用于比较2个迭代器的相等和不相等（==、!=）
- 用于推进迭代器的前置和后置递增运算（++）
- 用于读取元素的解引用运算符（*）；解引用只会出现在赋值运算符的右侧
- 箭头运算符（->），等价于(*it).member

**输出迭代器(output iterator)**: 可以看作输入迭代器功能上的补集——只写不读元素。输出迭代器必须支持
- 用于推进迭代器的前置和后置递增运算（++）
- 解引用运算符（*），只出现在赋值运算符的左侧

**前向迭代器(forward iterator)**: 可以读写元素，只能在序列中沿一个方向移动，支持输入和输出迭代器的所有操作，可以多次读写同一个元素。

**双向迭代器(bidirectional iterator)**: 可以正向/反向读写序列中的元素，在前向迭代器的基础操作之上，还支持前置和后置递减运算符。

**双向迭代器(bidirectional iterator)**: 除了支持双向迭代器的所有能力，还支持以下操作:
- 用于比较2个迭代器相对位置的关系运算符（<、<=、>、>=）
- 迭代器和一个整数值的加减运算（+、+=、-、-=）
- 用于2个迭代器上的减法运算符（-），得到2个迭代器的距离
- 下标运算符（iter[n]），与*(iter[n])等价

### 10.5.2 算法形参模式
`alg(beg, end, other args)`

`alg(beg, end, dest, other args)`

`alg(beg, end, beg2, other args)`

`alg(beg, end, beg2, end2, other args)`

### 10.5.3 算法命名规范

## 10.6 特定容器算法





## 第10章 练习题
### 10.1节练习
<b>练习10.1</b> 头文件algorithm中定义了一个名为count的函数，它类似find，接受一对迭代器和一个值作为参数。count返回给定值在序列中出现的次数。
编写程序，读取int序列存入vector中，打印有多少个元素的值等于给定值。

<b>练习10.2</b> 重做上一题，但读取string序列存入list中。

### 10.2.1节练习
<b>练习10.3</b> 用accumulate求一个vector<int>中的元素之和。

<b>练习10.4</b> 假定v是一个vector<double>，那么调用accumulate(v.cbegin(), v.cend(), 0)有何错误？

<b>练习10.5</b> 在本节对名册(roster)调用equal的例子中，如果2个名册中保存的都是C风格字符串而不是string，会发生什么？ 

### 10.2.2节练习
<b>练习10.6</b> 编写程序，使用fill_n将一个序列中的int值都设置为0.

<b>练习10.7</b> 下面程序是否有错误？如果有，请改正。
```text
(a) vector<int> vec; list<int> lst; int i;
    while(cin >> i)
        lst.push_back(i);
    copy(lst.cbegin(), lst.cend(), vec.begin());
(b) vector<int> vec;
    vec.reserve(10);
    fill_n(vec.begin(), 10, 0); 
```
<b>练习10.8</b> 标准库算法不会改变它们所操作的容器大小，为什么使用back_inserter可以？

### 10.2.3节练习
<b>练习10.9</b> 实现你自己的elim_dups。测试你的程序，分别在读取输入后、调用unique后以及调用erase后打印vector的内容。

<b>练习10.10</b> 你认为算法不改变容器大小的原因是什么？

### 10.3.1节练习
<b>练习10.11</b> 编写程序，使用stable_sort和isShorter将传递给你的elimDups版本的vector排序。打印vector的内容，验证程序的正确性。

<b>练习10.12</b> 编写名为compareIsbn函数，比较2个Sales_data对象的isbn()成员。使用这个函数排序一个保存Sales_data对象的vector。

<b>练习10.13</b> 标准库定义了名为partition的算法，它接受一个谓词，对容器内容进行划分，使得谓词为true的值会排在容器的前半部分，
而使谓词为false的值会排在后半部分。算法返回一个迭代器，指向最后一个使谓词为true的元素之后的位置。编写函数，接受一个string，返回一个bool值，
指出string是否有5个或更多字符。使用此函数划分words。打印出长度>=5的元素。

### 10.3.2节练习
<b>练习10.14</b> 编写一个lambda，接受2个int，返回它们的和。

<b>练习10.15</b> 编写一个lambda，捕获它所在函数的int，并接受一个int参数。lambda应该返回捕获的int和int参数的和。

<b>练习10.16</b> 使用lambda编写你自己版本的biggies。

<b>练习10.17</b> 重写10.3.1节练习10.12的程序，在对sort的调用中使用lambda来代替函数compareIsbn。

<b>练习10.18</b> 重写biggies，用partition代替find_if。我们在10.3.1节练习10.13中介绍了partition算法。

<b>练习10.19</b> 用stable_partition重写前一题的程序，与stable_sort类似，在划分后的序列中维持原有元素的顺序。

### 10.3.3节练习
<b>练习10.20</b> 标准库定义了一个名为count_if的算法。类似find_if，此函数接受一对迭代器，表示一个输入范围，还接受一个谓词，会对输入范围中每个元素执行。
count_if返回一个计数值，表示谓词有多少次为真。使用count_if重写我们程序中统计有多少单词长度超过6的部分。

<b>练习10.21</b> 编写一个lambda，捕获一个局部int变量，并递减变量值，直至它变为0.一旦变量为0，再调用lambda应该不再递减变量。lambda应该返回bool，
指出捕获的变量是否为0。

### 10.3.4节练习
<b>练习10.22</b> 重写统计长度小于等于6的单词数量的程序，使用函数代替lambda。

<b>练习10.23</b> bind接受几个参数？

<b>练习10.24</b> 给定一个string，使用bind和check_size在一个int的vector中查找第一个大于string长度的值。

<b>练习10.25</b> 在10.3.2节的练习中，编写一个使用partition的biggies版本。使用check_size和bind重写此函数。

### 10.4.1节练习
<b>练习10.26</b> 解释3种插入迭代器的不同之处。

<b>练习10.27</b> 除了unique之外，标准库还定义了名为unique_copy的函数，它接受第3个迭代器，表示拷贝不重复元素的目的位置。编写一个程序，使用unique_copy
将一个vector中不重复的元素拷贝到一个初始为空的list中。

<b>练习10.28</b> 一个vector中保存1到9，将其拷贝到3个其他容器中。分别使用inserter、back_inserter和front_inserter将元素添加到3个容器中。
对每种inserter估计输出序列是怎样的？运行程序验证你的估计是否正确。

### 10.4.2节练习
<b>练习10.29</b> 编写程序，使用流迭代器读取一个文本文件，存入一个vector的string里。

<b>练习10.30</b> 使用流迭代器、sort和copy从标准输入读取一个整数序列，将其排序，并将结果写到标准输出。

<b>练习10.31</b> 修改前一题的程序，使其只打印不重复的元素。你的程序应使用unique_copy。

<b>练习10.32</b> 重写1.6节中的书店程序，使用一个vector保存交易记录，使用不同算法完成处理。使用sort和10.3.1节中的compareIsbn函数来排序交易记录，
然后使用find和accumulate求和。

<b>练习10.33</b> 编写程序，接受3个参数：一个输入文件和2个输出文件的文件名。文件保存的应该是整数。使用istream_iterator读取输入文件。使用
ostream_iterator将奇数写入到第1个输出文件，每个值之后都跟着一个空格。将偶数写入到第2个输出文件中，每个值都独占一行。

### 10.4.3节练习
<b>练习10.34</b> 使用reverse_iterator逆序打印一个vector。

<b>练习10.35</b> 使用普通迭代器逆序打印一个vector。

<b>练习10.36</b> 使用find在一个int的list中查找最后一个值为0的元素。

<b>练习10.37</b> 给定一个包含10个元素的vector，将位置3到7之间的元素按逆序拷贝到一个list中。

### 10.5.1节练习
<b>练习10.38</b> 列出5个迭代器类别，以及每类迭代器所支持的操作。

<b>练习10.39</b> list上的迭代器属于哪类？vector呢？

<b>练习10.40</b> 你认为copy要求哪类迭代器？reverse和unique呢？

### 10.5.3节练习
<b>练习10.41</b> 仅根据算法和参数的名字，描述下面每个标准库算法执行什么操作：
```text
replace(beg, end, old_val, new_val);
replace_if(beg, end, pred, new_val);
replace_copy(beg, end, dest, old_val, new_val);
replace_copy_if(beg, end, dest, pred, new_val);
```

