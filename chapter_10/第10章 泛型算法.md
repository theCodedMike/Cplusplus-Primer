# 第10章 泛型算法
## 10.1 概述

## 10.2 初识泛型算法
### 10.2.1 只读算法
### 10.2.2 写容器元素的算法
### 10.2.3 重排容器元素的算法

## 10.3 定制操作
### 10.3.1 向算法传递函数
### 10.3.2 lambda表达式
### 10.3.3 lambda捕获和返回
### 10.3.4 参数绑定

## 10.4 再探迭代器
### 10.4.1 插入迭代器
### 10.4.2 iostream迭代器
### 10.4.3 反向迭代器

## 10.5 泛型算法结构
### 10.5.1 5类迭代器
### 10.5.2 算法形参模式
### 10.5.3 算法命名规范

## 10.6 特定容器算法





## 第10章 练习题
### 10.1节练习
<b>练习10.1</b> 头文件algorithm中定义了一个名为count的函数，它类似find，接受一对迭代器和一个值作为参数。count返回给定值在序列中出现的次数。
编写程序，读取int序列存入vector中，打印有多少个元素的值等于给定值。

<b>练习10.2</b> 重做上一题，但读取string序列存入list中。

### 10.2.1节练习
<b>练习10.3</b> 用accumulate求一个vector<int>中的元素之和。

<b>练习10.4</b> 假定v是一个vector<double>，那么调用accumulate(v.cbegin(), v.cend(), 0)有何错误？

<b>练习10.5</b> 在本节对名册(roster)调用equal的例子中，如果2个名册中保存的都是C风格字符串而不是string，会发生什么？ 

### 10.2.2节练习
<b>练习10.6</b> 编写程序，使用fill_n将一个序列中的int值都设置为0.

<b>练习10.7</b> 下面程序是否有错误？如果有，请改正。
```text
(a) vector<int> vec; list<int> lst; int i;
    while(cin >> i)
        lst.push_back(i);
    copy(lst.cbegin(), lst.cend(), vec.begin());
(b) vector<int> vec;
    vec.reserve(10);
    fill_n(vec.begin(), 10, 0); 
```
<b>练习10.8</b> 标准库算法不会改变它们所操作的容器大小，为什么使用back_inserter可以？

### 10.2.3节练习
<b>练习10.9</b> 实现你自己的elim_dups。测试你的程序，分别在读取输入后、调用unique后以及调用erase后打印vector的内容。

<b>练习10.10</b> 你认为算法不改变容器大小的原因是什么？













