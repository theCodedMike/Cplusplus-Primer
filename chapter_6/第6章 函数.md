# 第6章 函数

## 6.1 函数基础
### 6.1.1 局部对象
**局部静态对象**在程序的执行路径第一次经过对象定义语句时初始化，并且直到程序终止才被销毁，在此期间即使对象所在的函数结束也不会对它有影响。
### 6.1.2 函数声明
### 6.1.3 分离式编译

## 6.2 参数传递
### 6.2.1 传值参数
### 6.2.2 传引用参数
### 6.2.3 const形参和实参
### 6.2.4 数组形参
### 6.2.5 main:处理命令行选项
### 6.2.6 含有可变形参的函数

## 6.3 返回类型和return语句
### 6.3.1 无返回值函数
### 6.3.2 有返回值函数
不要返回局部对象的引用或指针
### 6.3.3 返回数组指针
`int (*(func(int i))[10]  返回值为指向数组的指针`

## 6.4 函数重载
如果回一作用域内的儿个函数名字相同但形参列表不同，我们称之为**重载**(overloaded)
### 6.4.1 重载与作用域

## 6.5 特殊用途语言特性
### 6.5.1 默认实参
一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值。

设计函数时，尽量让不怎么使用默认值的形参出现在前面，使用默认值的形参出现在后面。

### 6.5.2 内联函数和constexpr函数
**内联函数**可以在调用点处展开，可避免函数调用的开销。

内联机制一般用在规模较小、流程直接、频繁调用的函数。

与其他函数不同，内联函数和constexpr函数可以在程序中多次定义（须完全一致），且一般定义在头文件中，
### 6.5.3 调试帮助

## 6.6 函数匹配
### 6.6.1 实参类型转换

## 6.7 函数指针
```text
bool length_compare(const string &, const string &);
bool (*pf) (const string &, const string &);
匹配时要求返回类型和形参类型都一致

void use_bigger(const string &s1, const string &s2, bool pf(const string &, const string &));
void use_bigger(const string &s1, const string &s2, bool (*pf)(const string &, const string &));
```



## 第6章 练习题
### 6.1节练习
<b>练习6.1</b> 实参和形参的区别是什么？

<b>练习6.2</b> 请指出下列函数哪个有错误？为什么？应该如何修正呢？
```text
(a) int f() {
        string s;
        // ...
        return s;
    }
(b) f2(int i) { /* ... */ }
(c) int  calc(int v1, int v1) { /* ... */ }
(d) double square(double x) return x * x;
```
<b>练习6.3</b> 编写你自己的fact函数，上机检查是否正确。

<b>练习6.4</b> 编写一个与用户交互的函数，要求用户输入一个数字，计算生成该数字的阶乘。在main函数中调用该函数。

<b>练习6.5</b> 编写一个函数输出其实参的绝对值。

### 6.1.1节练习
<b>练习6.6</b> 说明形参、局部变量以及局部静态变量的区别。编写一个函数，同时用到这3种形式。

<b>练习6.7</b> 编写一个函数，当它第1次被调用时返回0，以后每次被调用返回值加1。

### 6.1.2节练习
<b>练习6.8</b> 编写一个名为Chapter6.h的头文件，令其包含6.1节练习种的函数声明。

### 6.1.3节练习
<b>练习6.9</b> 编写你自己的fact.cc和factMain.cc，这2个文件都应该包含上一小节练习种编写的Chapter6.h头文件。通过这些文件，理解你的编译器是如何
支持分离式编译的。

### 6.2.1节练习
<b>练习6.10</b> 编写一个函数，使用指针形参交换2个整数的值。在代码中调用该函数并输出交换后的结果，以此验证函数的正确性。

### 6.2.2节练习
<b>练习6.11</b> 编写并验证你自己的reset函数，使其作用于引用类型的参数。

<b>练习6.12</b> 改写6.2.1节中练习6.10的程序，使用引用而非指针交换2个整数的值。你觉得哪种方法更易于使用呢？为什么？

<b>练习6.13</b> 假设T是某种类型的名字，说明以下2个函数声明的区别：一个是`void f(T)`，另一个是`void f(&T)`。

<b>练习6.14</b> 举一个形参应该是引用类型的例子，再举一个形参不能是引用类型的例子。

<b>练习6.15</b> 说明find_char函数中的3个形参为什么是现在的类型。特别说明为什么s是常量引用而occurs是普通引用？为什么s和occurs是引用类型而c不是？
如果令s是普通引用会发生什么情况？如果令occurs是常量引用会发生什么情况？

### 6.2.3节练习
<b>练习6.16</b> 下面的这个函数虽然合法，但是不算特别有用。指出它的局限性并设法改善。
```c++
bool is_empty(string& s) {
    return s.empty();
}
```
<b>练习6.17</b> 编写一个函数，判断string对象中是否含有大写字母。编写另一个函数，把string对象全部改成小写形式。在这2个函数中你使用的形参类型相同吗？
为什么？

<b>练习6.18</b> 为下面的函数编写函数声明，从给定的名字中推测函数具备的功能。
```text
(a) 名为compare的函数，返回bool值，2个参数都是matrix类的引用。
(b) 名为change_val的函数，返回vector<int>的迭代器，有2个参数：一个是int，一个是vector<int>迭代器。
```
<b>练习6.19</b> 假定有如下声明，判断哪个调用合法哪个不合法。对于不合法的函数调用，说明原因。
```text
double calc(double);
int count(const string &, char);
int sum(vector<int>::iterator, vector<int>::iterator, int);
vector<int> vec(10);

(a) calc(23.4, 55.1);          (b) count("abcda", 'a');
(c) calc(66);                  (d) sum(vec.begin(), vec.end(), 3.8);
```
<b>练习6.20</b> 引用形参什么时候应该是常量引用？如果形参应该是常量引用，而我们将其设为了普通引用，会发生什么？


### 6.2.4节练习
<b>练习6.21</b> 编写一个函数，令其接受2个参数：一个是int型，另一个是int指针。函数比较int值和int指针所指向的值的大小并返回较大的那个。
在该函数中指针的类型应该是什么？

<b>练习6.22</b> 编写一个函数，令其交换2个int指针。

<b>练习6.23</b> 参考本节介绍的几个print函数，根据理解编写你自己的版本。依次调用每个函数使其输入下面定义的i和j。
```c++
int i = 0, j[2] = {0, 1};
```
<b>练习6.24</b> 描述下面这个函数的行为。如果代码中存在问题，请指出并修正。
```c++
void print(const int ia[10]) {
    for (size_t i = 0; i != 10; ++i)
        cout << ia[i] << endl;
}
```

### 6.2.5节练习
<b>练习6.25</b> 编写一个main函数，令其接受2个实参。把实参的内容连接成一个string对象并输出。

<b>练习6.26</b> 编写一个程序，使其接受本节所示的选项；输出传递给main函数的实参的内容。

### 6.2.6节练习
<b>练习6.27</b> 编写一个函数，它的参数是initializer_list<int>类型的对象，函数的功能是计算列表中所有元素的和。

<b>练习6.28</b> 在error_msg函数的第2个版本中包含ErrCode类型的参数，其中循环内的elem是什么类型？

<b>练习6.29</b> 在范围for循环中使用initializer_list对象时，应该将循环控制变量声明成引用类型吗？为什么？

### 6.3.2节练习
<b>练习6.30</b> 编译第200页的str_subrange函数，看看你的编译器是如何处理函数中的错误的。

<b>练习6.31</b> 什么情况下返回的引用无效？什么情况下返回的常量引用无效？

<b>练习6.32</b> 下面的函数合法吗？如果合法，说明其功能；如果不合法，修改其中的错误并解释。
```c++
int &get(int *array, int index) {
    return array[index];
}

int main() {
    int ia[10];
    for (int i = 0; i != 10; ++i)
        get(ia, i) = i;
}
```
<b>练习6.33</b> 编写一个递归函数，输出vector对象的内容。

<b>练习6.34</b> 如果factorial函数的停止条件如下，将会发生什么情况？
```c++
if (val != 0)
```
<b>练习6.35</b> 在调用factorial函数时，为什么我们传入的值是val-1而不是val--？

### 6.3.3节练习
<b>练习6.36</b> 编写一个函数声明，使其返回数组的引用并且该数组包含10个string对象。不要使用尾置返回类型、decltype或者类型别名。

<b>练习6.37</b> 为上一题的函数再写3个声明，一个使用类型别名，另一个使用尾置返回类型，最后一个使用decltype关键字。你觉得哪种形式最好？为什么？

<b>练习6.38</b> 修改arrPtr函数，使其返回数组的引用。

### 6.4节练习
<b>练习6.39</b> 说明在下面的每组声明中第2条声明语句是何含义？如果有非法的声明，请指出来。
```text
(a) int calc(int, int);
    int calc(const int, const int);
(b) int get();
    double get();
(c) int &reset(int *);
    double *reset(double *);
```

### 6.5.1节练习
<b>练习6.40</b> 下面的哪个声明是错误的？为什么？
```text
(a) int ff(int a, int b = 0, int c = 0);
(b) char *init(int ht = 24, int wd, char bckgrnd);
```
<b>练习6.41</b> 下面的哪个调用是非法的？为什么？哪个调用虽然合法但是与程序员的初衷不符？为什么？
```text
char *init(int ht, int wd = 80, char bckgrnd = ' ');
(a) init();     (b) init(24, 10);    (c) init(14, '*');
```
<b>练习6.42</b> 给make_plural函数(参见6.3.2节，第201页)的第2个形参赋予默认实参's'，利用新版本的函数输出单词success和failure的单词和复数形式。

### 6.5.2节练习
<b>练习6.43</b> 你会把下面的哪个声明和定义放在头文件中？哪个放在源文件中？为什么？
```text
(a) inline bool eq(const BigInt&, const BigInt&) {...}
(b) void putValues(int *arr, int size);
```
<b>练习6.44</b> 将6.2.2节的isShorter函数改写成内联函数。

<b>练习6.45</b> 回顾在前面的练习中你写的那些函数，它们应该是内联函数吗？如果是，将它们改写成内联函数；如果不是，为什么？

<b>练习6.46</b> 能把isShorter函数定义为constexpr函数吗？如果能，则改写；如果不能，为什么？

### 6.5.3节练习
<b>练习6.47</b> 改写6.3.2节练习中使用递归输出vector内容的程序，使其有条件地输出与执行过程有关的信息。例如，每次调用时输出vector对象的大小。
分别在打开和关闭调试器的情况下编译并执行这个程序。

<b>练习6.48</b> 说明下面这个循环的含义，它对assert的使用合理吗？
```c++
string s;
while(cin >> s && s != sought) {}
assert(cin);
```

### 6.6节练习
<b>练习6.49</b> 什么是候选函数？什么是可行函数？

<b>练习6.50</b> 已知有第217页对函数f的声明，对于下面的每一个调用列出可行函数。其中哪个函数是最佳匹配？如果调用不合法，是因为没有可匹配的函数还是
因为调用具有二义性？
```text
(a) f(2.56, 42)     (b) f(42)     (c) f(42, 0)     (d) f(2.56, 3.14)
```
<b>练习6.51</b> 编写函数f的4个版本，令其各输出一条可以区分的消息。验证上一个练习的答案，如果你回答错了，请反复学习本节内容。

### 6.6.1节练习
<b>练习6.52</b> 已知有如下声明，请指出下列调用中每个类型转换的等级。
```text
void manip(int, int);
double dobj;

(a) manip('a', 'z');         (b) manip(55.4, dobj);
```
<b>练习6.53</b> 说明下列每组声明中的第2条语句会产生什么影响，并指出哪些不合法。
```text
(a) int calc(int&, int&);
    int calc(const int&, const int&);
(b) int calc(char*, char*);
    int calc(const char*, const char*);
(c) int calc(char*, char*);
    int calc(char* const, char* const);
```

### 6.7节练习
<b>练习6.54</b> 编写函数的声明，令其接受2个int形参并且返回类型也是int，然后声明一个vector对象，令其元素是指向该函数的指针。

<b>练习6.55</b> 编写4个函数，分别对2个int值执行加法、减、乘、除运算；在上一题创建的vector对象中保存指向这些函数的指针。

<b>练习6.56</b> 调用上述vector对象中的每个元素并输出其结果。



