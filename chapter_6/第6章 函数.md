# 第6章 函数

## 6.1 函数基础
### 6.1.1 局部对象
**局部静态对象**在程序的执行路径第一次经过对象定义语句时初始化，并且直到程序终止才被销毁，在此期间即使对象所在的函数结束也不会对它有影响。
### 6.1.2 函数声明
### 6.1.3 分离式编译

## 6.2 参数传递

## 6.3 返回类型和return语句

## 6.4 函数重载

## 6.5 特殊用途语言特性

## 6.6 函数匹配

## 6.7 函数指针





## 第6章 练习题
### 6.1节练习
<b>练习6.1</b> 实参和形参的区别是什么？

<b>练习6.2</b> 请指出下列函数哪个有错误？为什么？应该如何修正呢？
```text
(a) int f() {
        string s;
        // ...
        return s;
    }
(b) f2(int i) { /* ... */ }
(c) int  calc(int v1, int v1) { /* ... */ }
(d) double square(double x) return x * x;
```
<b>练习6.3</b> 编写你自己的fact函数，上机检查是否正确。

<b>练习6.4</b> 编写一个与用户交互的函数，要求用户输入一个数字，计算生成该数字的阶乘。在main函数中调用该函数。

<b>练习6.5</b> 编写一个函数输出其实参的绝对值。

### 6.1.1节练习
<b>练习6.6</b> 说明形参、局部变量以及局部静态变量的区别。编写一个函数，同时用到这3种形式。

<b>练习6.7</b> 编写一个函数，当它第1次被调用时返回0，以后每次被调用返回值加1。

### 6.1.2节练习
<b>练习6.8</b> 编写一个名为Chapter6.h的头文件，令其包含6.1节练习种的函数声明。

### 6.1.3节练习
<b>练习6.9</b> 编写你自己的fact.cc和factMain.cc，这2个文件都应该包含上一小节练习种编写的Chapter6.h头文件。通过这些文件，理解你的编译器是如何
支持分离式编译的。

### 6.2.1节练习
<b>练习6.10</b> 编写一个函数，使用指针形参交换2个整数的值。在代码中调用该函数并输出交换后的结果，以此验证函数的正确性。

### 6.2.2节练习
<b>练习6.11</b> 编写并验证你自己的reset函数，使其作用于引用类型的参数。

<b>练习6.12</b> 改写6.2.1节中练习6.10的程序，使用引用而非指针交换2个整数的值。你觉得哪种方法更易于使用呢？为什么？

<b>练习6.13</b> 假设T是某种类型的名字，说明以下2个函数声明的区别：一个是`void f(T)`，另一个是`void f(&T)`。

<b>练习6.14</b> 举一个形参应该是引用类型的例子，再举一个形参不能是引用类型的例子。

<b>练习6.15</b> 说明find_char函数中的3个形参为什么是现在的类型。特别说明为什么s是常量引用而occurs是普通引用？为什么s和occurs是引用类型而c不是？
如果令s是普通引用会发生什么情况？如果令occurs是常量引用会发生什么情况？

### 6.2.3节练习
<b>练习6.16</b> 下面的这个函数虽然合法，但是不算特别有用。指出它的局限性并设法改善。
```c++
bool is_empty(string& s) {
    return s.empty();
}
```
<b>练习6.17</b> 编写一个函数，判断string对象中是否含有大写字母。编写另一个函数，把string对象全部改成小写形式。在这2个函数中你使用的形参类型相同吗？
为什么？

<b>练习6.18</b> 为下面的函数编写函数声明，从给定的名字中推测函数具备的功能。
```text
(a) 名为compare的函数，返回bool值，2个参数都是matrix类的引用。
(b) 名为change_val的函数，返回vector<int>的迭代器，有2个参数：一个是int，一个是vector<int>迭代器。
```
<b>练习6.19</b> 假定有如下声明，判断哪个调用合法哪个不合法。对于不合法的函数调用，说明原因。
```text
double calc(double);
int count(const string &, char);
int sum(vector<int>::iterator, vector<int>::iterator, int);
vector<int> vec(10);

(a) calc(23.4, 55.1);          (b) count("abcda", 'a');
(c) calc(66);                  (d) sum(vec.begin(), vec.end(), 3.8);
```
<b>练习6.20</b> 引用形参什么时候应该是常量引用？如果形参应该是常量引用，而我们将其设为了普通引用，会发生什么？


### 6.2.4节练习
<b>练习6.21</b> 编写一个函数，令其接受2个参数：一个是int型，另一个是int指针。函数比较int值和int指针所指向的值的大小并返回较大的那个。
在该函数中指针的类型应该是什么？

<b>练习6.22</b> 编写一个函数，令其交换2个int指针。

<b>练习6.23</b> 参考本节介绍的几个print函数，根据理解编写你自己的版本。依次调用每个函数使其输入下面定义的i和j。
```c++
int i = 0, j[2] = {0, 1};
```
<b>练习6.24</b> 描述下面这个函数的行为。如果代码中存在问题，请指出并修正。
```c++
void print(const int ia[10]) {
    for (size_t i = 0; i != 10; ++i)
        cout << ia[i] << endl;
}
```

### 6.2.5节练习
<b>练习6.25</b> 编写一个main函数，令其接受2个实参。把实参的内容连接成一个string对象并输出。

<b>练习6.26</b> 编写一个程序，使其接受本节所示的选项；输出传递给main函数的实参的内容。

### 6.2.6节练习
<b>练习6.27</b> 编写一个函数，它的参数是initializer_list<int>类型的对象，函数的功能是计算列表中所有元素的和。

<b>练习6.28</b> 在error_msg函数的第2个版本中包含ErrCode类型的参数，其中循环内的elem是什么类型？

<b>练习6.29</b> 在范围for循环中使用initializer_list对象时，应该将循环控制变量声明成引用类型吗？为什么？





