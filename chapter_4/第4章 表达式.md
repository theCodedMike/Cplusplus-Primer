# 第4章 表达式
## 4.1 基础
### 4.1.1 基本概念
**表达式**由一个或多个运算对象组成，对表达式求值将得到一个结果。字面值和变量是最简单的表达式。

当一个对象被用作右值时，用的是对象的值；当一个对象被用作左值时，用的是对象的内存地址。
### 4.1.2 优先级与结合律
### 4.1.3 求值顺序
## 4.2 算术运算符
<table>
    <tr>
        <th colspan="3">表4.1 算术运算符（左结合律）</th>
    </tr>
    <tr>
        <td>运算符</td> <td>功能</td> <td>用法</td>
    </tr>
    <tr>
        <td>+</td> <td>一元正号</td> <td>+ expr</td>
    </tr>
    <tr>
        <td>-</td> <td>一元负号</td> <td>- expr</td>
    </tr>
    <tr>
        <td>*</td> <td>乘法</td> <td>expr * expr</td>
    </tr>
    <tr>
        <td>/</td> <td>除法</td> <td>expr / expr</td>
    </tr>
    <tr>
        <td>%</td> <td>求余</td> <td>expr % expr</td>
    </tr>
    <tr>
        <td>+</td> <td>加法</td> <td>expr + expr</td>
    </tr>
    <tr>
        <td>-</td> <td>减法</td> <td>expr - expr</td>
    </tr>
</table>
C++11规定商一律向0取整（即直接去除小数部分）。

## 4.3 逻辑和关系运算符
<table>
    <tr>
        <th colspan="4">表4.2 逻辑运算符和关系运算符</th>
    </tr>
    <tr>
        <td>结合律</td> <td>运算符</td> <td>功能</td> <td>用法</td>
    </tr>
    <tr>
        <td>右</td> <td>!</td> <td>逻辑非</td> <td>!expr</td>
    </tr>
    <tr>
        <td>左</td> <td><</td> <td>小于</td> <td>expr < expr</td>
    </tr>
    <tr>
        <td>左</td> <td><=</td> <td>小于等于</td> <td>expr <= expr</td>
    </tr>
    <tr>
        <td>左</td> <td>></td> <td>大于</td> <td>expr > expr</td>
    </tr>
    <tr>
        <td>左</td> <td>>=</td> <td>大于等于</td> <td>expr >= expr</td>
    </tr>
    <tr>
        <td>左</td> <td>==</td> <td>等于</td> <td>expr == expr</td>
    </tr>
    <tr>
        <td>左</td> <td>!=</td> <td>不等于</td> <td>expr != expr</td>
    </tr>
    <tr>
        <td>左</td> <td>&&</td> <td>逻辑与</td> <td>expr && expr</td>
    </tr>
    <tr>
        <td>左</td> <td>||</td> <td>逻辑或</td> <td>expr || expr</td>
    </tr>
</table>

## 4.4 赋值运算符
赋值运算符的左侧运算对象必须是一个可修改的左值。

## 4.5 递增和递减运算符
```c++
i++; ++i; i--; --i;
```
## 4.6 成员访问运算符
`ptr->mem`等价于`(*ptr).mem`。

## 4.7 条件运算符
`cond ? expr1 : expr2`

## 4.8 位运算符
<table>
    <tr>
        <th colspan="3">表4.3 位运算符（左结合律）</th>
    </tr>
    <tr>
        <td>运算符</td> <td>功能</td> <td>用法</td>
    </tr>
    <tr>
        <td>~</td> <td>位求反</td> <td>~expr</td>
    </tr>
    <tr>
        <td><<</td> <td>左移</td> <td>expr1 << expr2</td>
    </tr>
    <tr>
        <td>>></td> <td>右移</td> <td>expr1 >> expr2</td>
    </tr>
    <tr>
        <td>&</td> <td>位与</td> <td>expr & expr</td>
    </tr>
    <tr>
        <td>^</td> <td>位异或</td> <td>expr ^ expr</td>
    </tr>
    <tr>
        <td>|</td> <td>位或</td> <td>expr | expr</td>
    </tr>
</table>
关于符号位如何处理没有明确的规定，强烈建议仅将位运算符用于处理无符号类型。

```text
unsigned char b1 = 101;       0 1 1 0 0 1 0 1
unsigned char b2 = 175;       1 0 1 0 1 1 1 1
b1 & b2                       0 0 1 0 0 1 0 1 (24个高阶位都是0)
b1 | b2                       1 1 1 0 1 1 1 1 (24个高阶位都是0)
b1 ^ b2                       1 1 0 0 1 0 1 0 (24个高阶位都是0)
    ~b1                       1 0 0 1 1 0 1 0 (24个高阶位都是1)
```

## 4.9 sizeOf运算符
sizeof运算符返回一条表达式或一个类型名字所占的字节数。
- 对char或类型为char的表达式执行sizeof运算，结果为1
- 对引用类型执行sizeof运算得到被引用对象所占空间的大小
- 对指针执行sizeof运算得到指针本身所占空间的大小
- 对解引用指针执行sizeof运算得到指针所指向的对象所占空间的大小，指针不需要有效
- 对数组执行sizeof运算得到整个数组所占空间的大小
- 对string对象或vector对象执行sizeof运算只返回该类型固定部分的大小，不会计算对象中的元素占用的空间

## 4.10 逗号运算符
**逗号运算符**含有2个运算对象，按照从左到右的顺序依次求值，其结果是最右侧表达式的值。

逗号运算符经常被用在for循环中。

## 4.11 类型转换
### 4.11.1 算术转换
### 4.11.2 其他隐式类型转换
### 4.11.3 显示转换
`cast-name<type>(expression)`

`static_cast`: 任何具有明确定义的类型转换，只要不包含底层const都可以使用。
`const_cast`: 只能改变运算对象的底层const。
`reinterpret_cast`: 通常为运算对象的位模式提供较低层次的重新解释。
`dynamic_cast`: 运行时进行类型转换。

## 4.12 运算符优先级表
<table>
    <tr>
        <th colspan="5">表4.4 运算符优先级</th>
    </tr>
    <tr>
        <td>序号</td> <td>结合律</td> <td>运算符</td> <td>功能</td> <td>用法</td>
    </tr>
    <tr>
        <td>1</td> <td>左</td> <td>::</td> <td>全局作用域</td> <td>::name</td>
    </tr>
    <tr>
        <td>2</td> <td>左</td> <td>::</td> <td>类作用域</td> <td>class::name</td>
    </tr>
    <tr>
        <td>3</td> <td>左</td> <td>::</td> <td>命名空间作用域</td> <td>namespace::name</td>
    </tr>
    <tr>
        <td>4</td> <td>左</td> <td>.</td> <td>成员选择</td> <td>object.member</td>
    </tr>
    <tr>
        <td>5</td> <td>左</td> <td>-></td> <td>成员选择</td> <td>pointer->member</td>
    </tr>
    <tr>
        <td>6</td> <td>左</td> <td>[]</td> <td>下标</td> <td>expr[expr]</td>
    </tr>
    <tr>
        <td>7</td> <td>左</td> <td>()</td> <td>函数调用</td> <td>name(expr_list)</td>
    </tr>
    <tr>
        <td>8</td> <td>左</td> <td>()</td> <td>类型构造</td> <td>type(expr_list)</td>
    </tr>
    <tr>
        <td>9</td> <td>右</td> <td>++</td> <td>后置递增运算</td> <td>lvalue++</td>
    </tr>
    <tr>
        <td>10</td> <td>右</td> <td>--</td> <td>后置递减运算</td> <td>lvalue--</td>
    </tr>
    <tr>
        <td>11</td> <td>右</td> <td>typeid</td> <td>类型ID</td> <td>typeid(type)</td>
    </tr>
    <tr>
        <td>12</td> <td>右</td> <td>typeid</td> <td>运行时类型ID</td> <td>typeid(expr)</td>
    </tr>
    <tr>
        <td>13</td> <td>右</td> <td>explicit cast</td> <td>类型转换</td> <td>cast_name(expr)</td>
    </tr>
    <tr>
        <td>14</td> <td>右</td> <td>++</td> <td>前置递增运算</td> <td>++lvalue</td>
    </tr>
    <tr>
        <td>15</td> <td>右</td> <td>--</td> <td>前置递减运算</td> <td>--lvalue</td>
    </tr>
    <tr>
        <td>16</td> <td>右</td> <td>~</td> <td>位求反</td> <td>~expr</td>
    </tr>
    <tr>
        <td>17</td> <td>右</td> <td>!</td> <td>逻辑非</td> <td>!expr</td>
    </tr>
    <tr>
        <td>18</td> <td>右</td> <td>-</td> <td>一元负号</td> <td>-expr</td>
    </tr>
    <tr>
        <td>19</td> <td>右</td> <td>+</td> <td>一元正号</td> <td>+expr</td>
    </tr>
    <tr>
        <td>20</td> <td>右</td> <td>*</td> <td>解引用</td> <td>*expr</td>
    </tr>
    <tr>
        <td>21</td> <td>右</td> <td>&</td> <td>取地址</td> <td>&lvalue</td>
    </tr>
    <tr>
        <td>22</td> <td>右</td> <td>()</td> <td>类型转换</td> <td>(type)expr</td>
    </tr>
    <tr>
        <td>23</td> <td>右</td> <td>sizeof</td> <td>对象的大小</td> <td>sizeof expr</td>
    </tr>
    <tr>
        <td>24</td> <td>右</td> <td>sizeof</td> <td>类型的大小</td> <td>sizeof(type)</td>
    </tr>
    <tr>
        <td>25</td> <td>右</td> <td>sizeof...</td> <td>参数包的大小</td> <td>sizeof...(name)</td>
    </tr>
    <tr>
        <td>26</td> <td>右</td> <td>new</td> <td>创建对象</td> <td>new type</td>
    </tr>
    <tr>
        <td>27</td> <td>右</td> <td>new[]</td> <td>创建数组</td> <td>new type[size]</td>
    </tr>
    <tr>
        <td>28</td> <td>右</td> <td>delete</td> <td>释放对象</td> <td>delete expr</td>
    </tr>
    <tr>
        <td>29</td> <td>右</td> <td>delete []</td> <td>释放数组</td> <td>delete[] expr)</td>
    </tr>
    <tr>
        <td>30</td> <td>右</td> <td>noexcept</td> <td>能否抛出异常</td> <td>noexcept(expr)</td>
    </tr>
    <tr>
        <td>31</td> <td>左</td> <td>->*</td> <td>指向成员选择的指针</td> <td>ptr->*ptr_to_member</td>
    </tr>
    <tr>
        <td>32</td> <td>左</td> <td>.*</td> <td>指向成员选择的指针</td> <td>obj.*ptr_to_member</td>
    </tr>
    <tr>
        <td>33</td> <td>左</td> <td>*</td> <td>乘法</td> <td>expr * expr</td>
    </tr>
    <tr>
        <td>34</td> <td>左</td> <td>/</td> <td>除法</td> <td>expr / expr</td>
    </tr>
    <tr>
        <td>35</td> <td>左</td> <td>%</td> <td>取模(取余)</td> <td>expr % expr</td>
    </tr>
    <tr>
        <td>36</td> <td>左</td> <td>+</td> <td>加法</td> <td>expr + expr</td>
    </tr>
    <tr>
        <td>37</td> <td>左</td> <td>-</td> <td>减法</td> <td>expr - expr</td>
    </tr>
    <tr>
        <td>38</td> <td>左</td> <td><<</td> <td>向左移位</td> <td>expr << expr</td>
    </tr>
    <tr>
        <td>39</td> <td>左</td> <td>>></td> <td>向右移位</td> <td>expr >> expr</td>
    </tr>
    <tr>
        <td>40</td> <td>左</td> <td><</td> <td>小于</td> <td>expr < expr</td>
    </tr>
    <tr>
        <td>41</td> <td>左</td> <td><=</td> <td>小于等于</td> <td>expr <= expr</td>
    </tr>
    <tr>
        <td>42</td> <td>左</td> <td>></td> <td>大于</td> <td>expr > expr</td>
    </tr>
    <tr>
        <td>43</td> <td>左</td> <td>>=</td> <td>大于等于</td> <td>expr >= expr</td>
    </tr>
    <tr>
        <td>44</td> <td>左</td> <td>==</td> <td>等于</td> <td>expr == expr</td>
    </tr>
    <tr>
        <td>45</td> <td>左</td> <td>!=</td> <td>不等于</td> <td>expr != expr</td>
    </tr>
    <tr>
        <td>46</td> <td>左</td> <td>&</td> <td>位与</td> <td>expr & expr</td>
    </tr>
    <tr>
        <td>47</td> <td>左</td> <td>^</td> <td>位异或</td> <td>expr ^ expr</td>
    </tr>
    <tr>
        <td>48</td> <td>左</td> <td>|</td> <td>位或</td> <td>expr | expr</td>
    </tr>
    <tr>
        <td>49</td> <td>左</td> <td>&&</td> <td>逻辑与</td> <td>expr && expr</td>
    </tr>
    <tr>
        <td>50</td> <td>左</td> <td>||</td> <td>逻辑或</td> <td>expr || expr</td>
    </tr>
    <tr>
        <td>51</td> <td>右</td> <td>? :</td> <td>条件</td> <td>expr ? expr : expr</td>
    </tr>
    <tr>
        <td>52</td> <td>右</td> <td>=</td> <td>赋值</td> <td>lvalue = expr</td>
    </tr>
    <tr>
        <td>53</td> <td>右</td> <td>*=、/=、%=、+=、-=、<<=、>>=、&=、|=、^=</td> <td>复合赋值</td> <td>lvalue += expr</td>
    </tr>
    <tr>
        <td>54</td> <td>右</td> <td>throw</td> <td>抛出异常</td> <td>throw expr</td>
    </tr>
    <tr>
        <td>55</td> <td>左</td> <td>,</td> <td>逗号</td> <td>expr, expr</td>
    </tr>
</table>












## 第4章 练习题
### 4.1.2节练习
<b>练习4.1</b> 表达式5+10*20/2的求值结果是多少？

<b>练习4.2</b> 根据4.12节中的表，在下述表达式的合理位置添加括号，使得添加后运算对象的组合顺序与添加前一致。

### 4.1.3节练习
<b>练习4.3</b> C++语言没有明确规定大多数二元运算符的求值顺序，给编译器优化留下了余地。这种策略实际上是在代码生成效率和程序潜在缺陷之间进行了权衡，你
认为这可以接受吗？为什么？

### 4.2节练习
<b>练习4.4</b> 在下面的表达式中添加括号，说明其求值的过程和最终结果。编写程序编译该表达式并输出其结果验证之前的判断。
```c++
12 / 3 * 4 + 5 * 15 + 24 % 4 / 2
```
<b>练习4.5</b> 写出下列表达式的求值结果。
```text
(a) -30 * 3 + 21 / 5     (b) -30 + 3 * 21 / 5
(c) 30 / 3 * 21 % 5      (d) -30 / 3 * 21 % 4
```
<b>练习4.6</b> 写出一条表达式用于确定一个整数是奇数还是偶数。

<b>练习4.7</b> 溢出是何含义？写出3条将导致溢出的表达式。

### 4.3节练习
<b>练习4.8</b> 说明在逻辑与、逻辑或以及相等性运算符中运算对象的求值顺序。

<b>练习4.9</b> 解释在下面的if语句中条件部分的判断过程。
```c++
const char *p = "Hello World";
if (cp && *cp)
```
<b>练习4.10</b> 为while循环写一个条件，使其从标准输入中读取整数，遇到42时停止。

<b>练习4.11</b> 书写一条表达式用于测试4个值a、b、c、d的关系，确保a大于b、b大于c、c大于d。

<b>练习4.12</b> 假设i、j和k是3个整数，说明表达式i != j < k的含义。

### 4.4节练习
<b>练习4.13</b> 在下述语句中，当赋值完成后i和d的值分别是多少？
```text
int i; double d;
(a) d = i = 3.5;     (b) i = d = 3.5;
```
<b>练习4.14</b> 执行下述if语句后将发生什么情况？
```c++
if (42 = i) // ...
if (i = 42) // ...
```
<b>练习4.15</b> 下面的赋值是非法的，为什么？如何修正？
```c++
double dVal; int iVal; int *pi;
dVal = iVal = pi = 0;
```
<b>练习4.16</b> 尽管下面的语句合法，但它们实际执行的行为可能和预期不一样，为什么？如何修正？
```text
(a) if(p = getPtr() != 0)    (b) if(i = 1024)
```

### 4.5节练习
<b>练习4.17</b> 说明前置递增运算符和后置递增运算符的区别。

<b>练习4.18</b> 如果第132页那个输出vector对象元素的while循环使用前置递增运算符，将得到什么结果？

<b>练习4.19</b> 假设ptr的类型是指向int的指针、vec的类型是vector<int>、ival的类型是int，说明下面的表达式是何含义？如果有表达式不正确，为什么？
如何修正？
```text
int *ptr; vector<int> vec; int ival;
(a) ptr != 0 && *ptr++
(b) ival++ && ival
(c) vec[ival++] <= vec[ival]
```

### 4.6节练习
<b>练习4.19</b> 假设iter的类型是vector<string>::iterator，说明下面的表达式是否合法。如果合法，表达式的含义是什么？如果不合法，错在何处？
```text
(a) *iter++;             (b) (*iter)++;        (c) *iter.empty();
(d) iter->empty();       (e) ++*iter;          (f) iter++->empty();
```
### 4.7节练习
<b>练习4.21</b> 编写一段程序，使用条件运算符从vector<int>中找到哪些元素的值是奇数，然后将这些奇数值翻倍。

<b>练习4.22</b> 本节的示例程序将成绩划分成high pass、pass和fail三种，扩展该程序使其进一步将60分到75分之间的成绩设定为low pass。要求程序包含
2个版本：一个版本只使用运算符；另一个版本使用1个或多个if语句。哪个版本的程序更容易理解呢？为什么？

<b>练习4.23</b> 因为运算符的优先级问题，下面这个表达式无法通过编译。根据4.12节中的表（第147页）指出它的问题在哪里？该如何修改？
```c++
string s = "word";
string p1 = s + s[s.size() - 1] == 's' ? "" : "s";
```
<b>练习4.24</b> 本节的示例程序将成绩划分成high pass、pass和fail三种，它的依据是条件运算符满足右结合律。假如条件运算符满足的是左结合律，
求值过程将是怎样的？

### 4.8节练习
<b>练习4.25</b> 如果一台机器上int占32位、char占8位，用的是Latin-1字符集，其中字符'q'的二进制形式是01110001，那么表达式'q' << 6的值是什么？

<b>练习4.26</b> 在本节关于测验成绩的例子中，如果使用unsigned int作为quiz1的类型会发生什么情况？

<b>练习4.27</b> 下列表达式的结果是什么？
```text
unsigned long u11 = 3, u12 = 7;
(a) u11 & u12          (b) u11 | u12
(c) u11 && u12         (d) u11 || u12
```

### 4.9节练习
<b>练习4.28</b> 编写一段程序，输出每一种内置类型所占空间的大小。

<b>练习4.29</b> 推断下面代码的输出结果并说明理由。实际运行这段程序，结果是否如你所想。如果不同，请说明原因。

<b>练习4.30</b> 根据4.12节中的表，在下述表达式的适当位置加上括号，使得加上括号之后表达式的含义与原来的含义相同。
```text
(a) sizeof x + y        (b) sizeof p->mem[i]
(c) sizeof a < b        (d) sizeof f()
```

### 4.10节练习
<b>练习4.31</b> 本节的程序使用了前置版本的递增运算符和递减运算符，解释为什么要用前置版本而不是后置版本。使用后置版本重写本节的程序。

<b>练习4.32</b> 解释下面这个循环的含义。
```c++
constexpr int size = 5;
int ia[size] = {1, 2, 3, 4, 5};
for (int *ptr = ia, ix = 0; ix != size && ptr != ia + size; ++ix, ++ptr) {
    /**/
}
```
<b>练习4.33</b> 根据4.12节中的表，说梦下面这个表达式的含义。
```text
someValue ? ++x, ++y : --x, --y
```

### 4.11.1节练习
<b>练习4.34</b> 根据本节给出的变量定义，说明在下面的表达式中将发生什么样的类型转换：
```text
(a) if(fval)    (b) dval = fval + ival;   (c) dval + ival * cval
```
<b>练习4.35</b> 假设有如下的定义
```text
char cval;      int ival;       unsigned int ui;
float fval;     double dval;
```
请回答在下面的表达式中发生了隐式类型转换吗？如果有，哪个转换是隐式转换？
```text
(a) cval = 'a' + 3;       (b) fval = ui - ival * 1.0;
(c) dval = ui * fval;     (d) cval = ival + fval + dval;
```

### 4.11.3节练习
<b>练习4.36</b> 假设i是int类型，d是double类型，书写表达式i *= d使其执行整数类型的乘法而非浮点数类型的乘法。

<b>练习4.37</b> 用命名的强制类型转换改写下列旧式的转换语句。
```text
int i; double d; const string *ps; char *pc; void *pv;
(a) pv = (void *)ps;     (b) i = int(*pc);
(c) pv = &d;             (d) pc = (char *) pv;
```
<b>练习4.38</b> 说明下面这条表达式的含义。
```c++
double slope = static_cast<double>(j / i);
```



