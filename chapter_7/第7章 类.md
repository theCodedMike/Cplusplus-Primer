# 第7章 类
## 7.1 定义抽象数据类型
### 7.1.1 设计Sales_data类
### 7.1.2 定义改进的Sales_data类
**成员函数**的*声明*必须在类的内部，*定义*可以在类的内部或外部；对于**非成员函数**，其声明和定义都在类的外部。

定义在类内部的函数是隐式的inline函数。
### 7.1.3 定义类相关的非成员函数
### 7.1.4 构造函数
只有当类没有声明任何构造函数时，编译器才会自动生成默认构造函数。
### 7.1.5 拷贝、赋值和析构

## 7.2 访问控制与封装
struct和class都可以用来定义类，区别在于，对于struct，定义在第1个访问说明符之前的成员是public的；而对于class，定义在第1个访问修饰符之前的成员是private的。
### 7.2.1 友元
友元声明只能出现在类定义的内部，但是在类内出现的具体位置不限。友元不是类的成员，所以不受它所在区域访问控制级别的约束。

## 7.3 类的其他特性
### 7.3.1 类成员再探
### 7.3.2 返回*this的成员函数
### 7.3.3 类类型
### 7.3.4 友元再探

## 7.4 类的作用域
### 7.4.1 名字查找与类的作用域

## 7.5 构造函数再探
### 7.5.1 构造函数初始值列表
### 7.5.2 委托构造函数
### 7.5.3 默认构造函数的作用
### 7.5.4 隐式的类类型转换
在要求隐式转换的程序上下文中，我们可以通过将构造函数声明为`explicit`加以阻止.

关键字`explicit`只对一个实参的构造函数有效，且只能出现在类内的构造函数声明处。

### 7.5.5 聚合类
**聚合类**的条件:
- 所有成员都是public的
- 没有定义任何构造函数
- 没有类内初始值
- 没有基类，也没有virtual函数
### 7.5.6 字面值常量类

## 7.6 类的静态成员


## 第7章 练习题
### 7.1.1节练习
<b>练习7.1</b> 使用2.6.1节练习定义的Sales_data类为1.6节的交易处理程序编写一个新版本。

### 7.1.2节练习
<b>练习7.2</b> 我们曾在2.6.2节的练习中编写了一个Sales_data类。请向这个类添加combine和isbn成员。

<b>练习7.3</b> 修改7.1.1节的交易处理程序，令其使用这些成员。

<b>练习7.4</b> 编写一个名为Person的类，使其表示人员的姓名和住址。使用string对象存放这些元素，接下来的练习将不断充实这个类的其他特征。

<b>练习7.5</b> 在你的Person类中提供一个操作使其能够返回姓名和住址。这些函数是否应该是const的呢？为什么？

### 7.1.3节练习
<b>练习7.6</b> 对于函数add、read和print，定义你自己的版本。

<b>练习7.7</b> 使用这些新函数重写7.1.2练习中的交易处理程序。

<b>练习7.8</b> 为什么read函数将其Sales_data参数定义成普通的引用，而print将其参数定义成常量引用？

<b>练习7.9</b> 对于7.1.2节练习中的代码，添加读取和打印Person对象的操作。

<b>练习7.10</b> 在下面这条if语句中，条件部分的作用是什么？
```c++
if (read(read(cin, data1), data2))
```

### 7.1.4节练习
<b>练习7.11</b> 在你的Sales_data类中添加构造函数，然后编写一段程序令其用到每个构造函数。

<b>练习7.12</b> 把只接受一个istream作为参数的构造函数定义移到类的内部。

<b>练习7.13</b> 使用istream构造函数重写第229页的程序。

<b>练习7.14</b> 编写一个构造函数，令其用我们提供的类内初始值显示地初始化成员。

<b>练习7.15</b> 为你的Person类添加正确的构造函数。

### 7.2节练习
<b>练习7.16</b> 在类的定义中对于访问说明符出现的位置和次数有限定吗？如果有，是什么？什么样的成员应该定义在public说明符之后？
什么样的成员应该定义在private说明符之后？

<b>练习7.17</b> 使用class和struct时有区别吗？如果有，是什么？

<b>练习7.18</b> 封装是何含义？它有什么用处？

<b>练习7.19</b> 在你的Person类中，你将把哪些成员声明成public？哪些声明成private？解释为什么。

### 7.2.1节练习
<b>练习7.20</b> 友元在什么时候有用？请分别列举出使用友元的利弊。

<b>练习7.21</b> 修改你的Sales_data类使其隐藏实现的细节。你之前编写的关于Sales_data操作的程序应该继续使用，借助类的新定义重新编译该程序，
确保其正常工作。

<b>练习7.22</b> 修改你的Person类使其隐藏实现的细节。

### 7.3.1节练习
<b>练习7.23</b> 编写你自己的Screen类。

<b>练习7.24</b> 给你的Screen类添加3个构造函数：一个默认构造函数；另一个构造函数接受宽和高的值，然后将contents初始化成给定数量的空白；第3个构造函数
接受宽和高的值以及一个字符，该字符作为初始化之后屏幕的内容。

<b>练习7.25</b> Screen能安全地依赖于拷贝和赋值操作的默认版本吗？说明理由。

<b>练习7.26</b> 将Sales_data::avg_price定义成内联函数。

### 7.3.2节练习
<b>练习7.27</b> 给你自己的Screen类添加move、set和display函数，通过执行下面的代码检验你的类是否正确。

<b>练习7.28</b> 如果move、set和display函数的返回类型不是Screen&而是Screen，则在上一个练习中将会发生情况？

<b>练习7.29</b> 修改你的Screen类，令move、set和display函数返回Screen并检验程序的运行结果，在上一个练习中你的推测正确吗？

<b>练习7.30</b> 通过this指针使用成员的做法虽然合法，但是有点多余。讨论显式地使用指针访问成员的优缺点。

### 7.3.3节练习
<b>练习7.31</b> 定义一对类X和Y，其中X包含一个指向Y的指针，而Y包含一个类型为X的对象。

### 7.3.4节练习
<b>练习7.32</b> 定义你自己的Screen和Window_mgr，其中clear是Window_mgr的成员函数，是Screen的友元。

### 7.4节练习
<b>练习7.33</b> 如果我们给Screen添加一个如下所示的size成员将发生什么情况？如果出现了问题，请修复它。
```c++
pos Screen::size() const {
    return width * height;
}
```

### 7.4.1节练习
<b>练习7.34</b> 如果我们把第256页Screen类的pos的typedef放在类的最后一行会发生什么情况？

<b>练习7.35</b> 解释下面代码的含义，说明其中的Type和initVal分别使用了哪个定义。如果代码存在错误，请找出错误并修复它。
```c++
typedef string Type;
Type initVal();

class Exercise {
public:
    typedef double Type;
    Type setVal(Type);
    Type initVal();
private:
    int val;
};

Type Exercise::setVal(Type parm) {
    val = parm + initVal();
    return val;
}
```

### 7.5.1节练习
<b>练习7.36</b> 下面的初始值是错误的，请找出问题所在并尝试修改。
```c++
struct X {
   X(int i, int j) : base(i), rem(base % j) {}
   int rem, base;
}
```
<b>练习7.37</b> 使用本节提供的Sales_data类，确定初始化下面的变量时分别使用了哪个构造函数，然后罗列出每个对象所有数据成员的值。
```c++
Sales_data first_item(cin);

int main() {
    Sales_data next;
    Sales_data last("9-999-99999-9");
}
```

<b>练习7.38</b> 有些情况下我们希望提供cin作为接受istream&参数的构造函数的默认实参，请声明这样的构造函数。

<b>练习7.39</b> 如果接受string的构造函数和接受istream&的构造函数都使用默认实参，这样合法吗？为什么？

<b>练习7.40</b> 从下面的抽象概念中选择一个（或者你自己指定一个），思考这样的类需要哪些数据成员，提供一组合理的构造函数并阐明这样做的原因。
```c++
(a) Book        (b) Date       (c) Employee
(d) Vehicle     (e) Object     (f) Tree
```

### 7.5.2节练习
<b>练习7.41</b> 使用委托构造函数重新编写你的Sales_data类，给每个构造函数体添加一条语句，令其一旦执行就打印一条信息。用各种可能的方式分别创建
Sales_data对象，认真研究每次输出的信息直到你确实理解了委托构造函数的执行顺序。

<b>练习7.42</b> 对于你在练习7.40中编写的类，确定哪些构造函数可以使用委托。如果可以的话，编写委托构造函数。如果不可以，从抽象概念列表中重新选择一个
你认为可以使用委托构造哈桑农户的，为挑选出的这个概念编写类定义。


### 7.5.3节练习
<b>练习7.43</b> 假定有一个名为NoDefault的类，它有一个接受int的构造函数，但是没有默认构造函数。定义类C，C有一个NoDefault类型的成员，定义C的默认构造函数。

<b>练习7.44</b> 下面这条声明合法吗？如果不，为什么？
```c++
vector<NoDefault> vec(10);
```
<b>练习7.45</b> 如果在上一个练习中定义的vector的元素类型是C，则声明合法吗？为什么？

<b>练习7.46</b> 下面哪些论断是不正确的？为什么？
```text
(a) 一个类必须至少提供一个构造函数。
(b) 默认构造函数是参数列表为空的构造函数。
(c) 如果对于类来说不存在有意义的默认值，则类不应该提供默认构造函数。
(d) 如果类没有定义默认构造函数，则编译器将为其生成一个并把每个数据成员初始化成相应类型的默认值。
```

### 7.5.4节练习
<b>练习7.47</b> 说明接受一个string参数的Sales_data构造函数是否应该是explicit的，并解释这样做的优缺点。

<b>练习7.48</b> 假定Sales_data的构造函数不是explicit的，则下述定义将执行什么样的操作？如果是explicit的，又会发生什么呢？
```c++
string null_isbn("9-999-99999-9");
Sales_data item1(null_isbn);
Sales_data item2("9-999-99999-9");
```
<b>练习7.49</b> 对于combine函数的3种不同声明，当我们调用i.combine(s)时分别发生什么情况？其中i时一个Sales_data，而s时一个string对象。
```text
(a) Sales_data & combine(Sales_data);
(b) Sales_data & combine(Sales_data&);
(c) Sales_data & combine(const Sales_data&) const;
```
<b>练习7.50</b> 确定在你的Person类中是否有一些构造函数应该是explicit的。

<b>练习7.51</b> vector将其单参数的构造函数定义成explicit的，而string则不是，为什么？

### 7.5.5节练习
<b>练习7.52</b> 使用2.6.1节的Sales_data类，解释下面的初始化过程。如果存在问题，请修复它。
```c++
Sales_data item = {"978-0590353403", 25, 15.99};
```

### 7.5.6节练习
<b>练习7.53</b> 定义你自己的Debug。

<b>练习7.54</b> Debug中以set_开头的成员应该被声明成constexpr吗？为什么？

<b>练习7.55</b> 7.5.5节的Data类是字面值常量类吗？为什么？




