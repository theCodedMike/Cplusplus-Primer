# 第7章 类
## 7.1 定义抽象数据类型
### 7.1.1 设计Sales_data类
### 7.1.2 定义改进的Sales_data类
**成员函数**的*声明*必须在类的内部，*定义*可以在类的内部或外部；对于**非成员函数**，其声明和定义都在类的外部。

定义在类内部的函数是隐式的inline函数。





### 7.1.3 定义类相关的非成员函数
### 7.1.4 构造函数
只有当类没有声明任何构造函数时，编译器才会自动生成默认构造函数。


### 7.1.5 拷贝、赋值和析构

## 7.2 访问控制与封装
### 7.2.1 友元

## 7.3 类的其他特性
### 7.3.1 类成员再探
### 7.3.2 返回*this的成员函数
### 7.3.3 类类型
### 7.3.4 友元再探

## 7.4 类的作用域
### 7.4.1 名字查找与类的作用域

## 7.5 构造函数再探
### 7.5.1 构造函数初始值列表
### 7.5.2 委托构造函数
### 7.5.3 默认构造函数的作用
### 7.5.4 隐式的类类型转换
### 7.5.5 聚合类
### 7.5.6 字面值常量类

## 7.6 类的静态成员


## 第7章 练习题
### 7.1.1节练习
<b>练习7.1</b> 使用2.6.1节练习定义的Sales_data类为1.6节的交易处理程序编写一个新版本。

### 7.1.2节练习
<b>练习7.2</b> 我们曾在2.6.2节的练习中编写了一个Sales_data类。请向这个类添加combine和isbn成员。

<b>练习7.3</b> 修改7.1.1节的交易处理程序，令其使用这些成员。

<b>练习7.4</b> 编写一个名为Person的类，使其表示人员的姓名和住址。使用string对象存放这些元素，接下来的练习将不断充实这个类的其他特征。

<b>练习7.5</b> 在你的Person类中提供一个操作使其能够返回姓名和住址。这些函数是否应该是const的呢？为什么？

### 7.1.3节练习
<b>练习7.6</b> 对于函数add、read和print，定义你自己的版本。

<b>练习7.7</b> 使用这些新函数重写7.1.2练习中的交易处理程序。

<b>练习7.8</b> 为什么read函数将其Sales_data参数定义成普通的引用，而print将其参数定义成常量引用？

<b>练习7.9</b> 对于7.1.2节练习中的代码，添加读取和打印Person对象的操作。

<b>练习7.10</b> 在下面这条if语句中，条件部分的作用是什么？
```c++
if (read(read(cin, data1), data2))
```

### 7.1.4节练习
<b>练习7.11</b> 在你的Sales_data类中添加构造函数，然后编写一段程序令其用到每个构造函数。

<b>练习7.12</b> 把只接受一个istream作为参数的构造函数定义移到类的内部。

<b>练习7.13</b> 使用istream构造函数重写第229页的程序。

<b>练习7.14</b> 编写一个构造函数，令其用我们提供的类内初始值显示地初始化成员。

<b>练习7.15</b> 为你的Person类添加正确的构造函数。










