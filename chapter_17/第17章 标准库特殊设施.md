# 第17章 标准库特殊设施
## 17.1 tuple类型
### 17.1.1 定义和初始化tuple
由于`tuple`定义了`<`和`==`运算符，所以可以作为**有序容器**的key。

### 17.1.2 使用tuple返回多个值

## 17.2 bitset类型
### 17.2.1 定义和初始化bitset
### 17.2.2 bitset操作

## 17.3 正则表达式
### 17.3.1 使用正则表达式库
<table>
    <th colspan="2">表17.8 正则表达式库类</th>
    <tr>
        <td><b>如果输入序列类型</b></td> <td><b>则使用正则表达式类</b></td>
    </tr>
    <tr>
        <td>string</td> <td>regex、smatch、ssub_match、sregex_iterator</td>
    </tr>
    <tr>
        <td>const char*</td> <td>regex、cmatch、csub_match、cregex_iterator</td>
    </tr>
    <tr>
        <td>wstring</td> <td>wregex、wsmatch、wssub_match、wsregex_iterator</td>
    </tr>
    <tr>
        <td>const wchar_t*</td> <td>wregex、wcmatch、wcsub_match、wcregex_iterator</td>
    </tr>
</table>

### 17.3.2 匹配与Regex迭代器类型
### 17.3.3 使用子表达式
### 17.3.4 使用regex_replace

## 17.4 随机数
| 引擎                         | 备注       |
|----------------------------|----------|
| default_random_engine      | 适用于大多数情况 |
| linear_congruential_engine |          |
| mersenne_twister_engine    | 梅森旋转生成   |
| subtract_with_carry_engine |          |
| discard_block_engine       |          |
| independent_bits_engine    |          |
| shuffle_order_engine       |          |

<table>
    <tr style="text-align: center;">
        <td><b>分布</b></td> <td><b>备注</b></td>
    </tr>
    <tr style="background-color: mediumseagreen;">
        <td><b>均匀分布</b></td> <td></td>
    </tr>
    <tr>
        <td>uniform_int_distribution< IntT> u(m, n)</td> <td>生成指定类型给定范围内的值; m默认为0, n是类型IntT的最大值, x默认为0, y默认为1.0</td>
    </tr>
    <tr>
        <td>uniform_real_distribution< RealT> u(x, y)</td> <td></td>
    </tr>
    <tr style="background-color: mediumseagreen;">
        <td><b>伯努利分布</b></td> <td></td>
    </tr>
    <tr>
        <td>bernoulli_distribution b(p);</td> <td>以给定概率p生成true；p的默认值是0.5</td>
    </tr>
    <tr>
        <td>binomial_distribution< IntT> b(t, p);</td> <td>分布按采样大小t、概率为p生成；t的默认值是1, p的默认值是0.5</td>
    </tr>
    <tr>
        <td>geometric_distribution< IntT> g(p);</td> <td>每次试验成功的概率为p, p的默认值是0.5</td>
    </tr>
    <tr>
        <td>negative_binomial_distribution< IntT> nb(k, p);</td> <td>k次试验成功的概率为p，k的默认值为1, p的默认值是0.5</td>
    </tr>
    <tr style="background-color: mediumseagreen;">
        <td><b>泊松分布</b></td> <td></td>
    </tr>
    <tr>
        <td>poisson_distribution< IntT> p(x);</td> <td>均值为double值x的分布</td>
    </tr>
    <tr>
        <td>exponential_distribution< RealT> e(lam);</td> <td>指数分布，lam的默认值是1.0</td>
    </tr>
    <tr>
        <td>gamma_distribution< RealT> g(a, b);</td> <td>a为形状参数，b为尺度参数;二者默认值均为1.0</td>
    </tr>
    <tr>
        <td>weibull_distribution< RealT> w(a, b);</td> <td>同上</td>
    </tr>
    <tr>
        <td>extreme_value_distribution< RealT> e(a, b);</td> <td>a的默认值为0，b的默认值为1.0</td>
    </tr>
    <tr style="background-color: mediumseagreen;">
        <td><b>正太分布</b></td> <td></td>
    </tr>
    <tr>
        <td>normal_distribution< RealT> n(m, s);</td> <td>均值为m标准差为s；m的默认值为0，s的默认值为1.0</td>
    </tr>
    <tr>
        <td>lognormal_distribution< RealT> ln(m, s);</td> <td>同上</td>
    </tr>
    <tr>
        <td>chi_squared_distribution< RealT> c(x);</td> <td>自由度为x；默认值为1.0</td>
    </tr>
    <tr>
        <td>cauchy_distribution< RealT> c(a, b);</td> <td>位置参数a和尺度参数b的默认值分别为0和1.0</td>
    </tr>
    <tr>
        <td>fisher_f_distribution< RealT> f(m, n);</td> <td>自由度为m和n，默认值均为1.0</td>
    </tr>
    <tr>
        <td>student_t_distribution< RealT> s(n);</td> <td>自由度为n，默认值为1.0</td>
    </tr>
    <tr style="background-color: mediumseagreen;">
        <td><b>抽样分布</b></td> <td></td>
    </tr>
    <tr>
        <td>discrete_distribution< IntT> d(i, j);</td> <td>i、j是权重序列的输入迭代器。权重须能转换为double</td>
    </tr>
    <tr>
        <td>discrete_distribution< IntT> d(il);</td> <td></td>
    </tr>
    <tr>
        <td>piecewise_constant_distribution< RealT> pc(b, e, w);</td> <td>b、e、w均是输入迭代器</td>
    </tr>
    <tr>
        <td>piecewise_linear_distribution< RealT> pl(b, e, w);</td> <td>同上</td>
    </tr>
</table>

### 17.4.1 随机数引擎和分布
<table>
    <th colspan="2">表17.15 随机数引擎操作</th>
    <tr>
        <td>Engine e;</td> <td>默认构造函数；使用该引擎类型默认的种子</td>
    </tr>
    <tr>
        <td>e.seed(s)</td> <td>使用种子s重置引擎的状态</td>
    </tr>
    <tr>
        <td>e.min()</td> <td>此引擎可生成的最小值</td>
    </tr>
    <tr>
        <td>e.max()</td> <td></td>
    </tr>
    <tr>
        <td>Engine::result_type</td> <td></td>
    </tr>
    <tr>
        <td>e.discard(u)</td> <td>将引擎推进u步，u的类型为unsigned long long</td>
    </tr>
</table>

### 17.4.2 其他随机数分布
<table>
    <th colspan="2">表17.16 分布类型的操作</th>
    <tr>
        <td>Dist d;</td> <td>默认构造函数</td>
    </tr>
    <tr>
        <td>d(e)</td> <td>e为引擎</td>
    </tr>
    <tr>
        <td>d.min()</td> <td>返回d(e)能生成的最小值和最大值</td>
    </tr>
    <tr>
        <td>d.max()</td> <td></td>
    </tr>
    <tr>
        <td>d.reset()</td> <td>重置d的状态</td>
    </tr>
</table>

## 17.5 IO库再探
### 17.5.1 格式化输入与输出
<table>
    <th colspan="3">表17.17 定义在iostream中的操作符</th>
    <tr>
        <td></td> <td>boolalpha</td> <td>将true和false输出为字符串</td>
    </tr>
    <tr>
        <td>*</td> <td>noboolalpha</td> <td>将true和false输出为数字</td>
    </tr>
    <tr>
        <td></td> <td>showbase</td> <td>对整型值输出表示进制的前缀</td>
    </tr>
    <tr>
        <td>*</td> <td>noshowbase</td> <td>不生成表示进制的前缀</td>
    </tr>
    <tr>
        <td></td> <td>showpoint</td> <td>对浮点值总是显示小数点</td>
    </tr>
    <tr>
        <td>*</td> <td>noshowpoint</td> <td>只有当浮点值包含小数部分时才显示小数点</td>
    </tr>
    <tr>
        <td></td> <td>showpos</td> <td>对非负数显示+</td>
    </tr>
    <tr>
        <td>*</td> <td>noshowpos</td> <td>对非负数不显示+</td>
    </tr>
    <tr>
        <td></td> <td>uppercase</td> <td>在16进制打印0X, 科学计数法中打印E</td>
    </tr>
    <tr>
        <td>*</td> <td>nouppercase</td> <td>在16进制打印0x, 科学计数法中打印e</td>
    </tr>
    <tr>
        <td>*</td> <td>dec</td> <td>整型值显示为10进制</td>
    </tr>
    <tr>
        <td></td> <td>hex</td> <td>整型值显示为16进制</td>
    </tr>
    <tr>
        <td></td> <td>oct</td> <td>整型值显示为8进制</td>
    </tr>
    <tr>
        <td></td> <td>left</td> <td>在值的右侧填充字符</td>
    </tr>
    <tr>
        <td></td> <td>right</td> <td>在值的左侧填充字符</td>
    </tr>
    <tr>
        <td></td> <td>internal</td> <td>在符号和值之间填充字符</td>
    </tr>
    <tr>
        <td></td> <td>fixed</td> <td>浮点值显示为定点10进制</td>
    </tr>
    <tr>
        <td></td> <td>scientific</td> <td>浮点值显示为科学计数法</td>
    </tr>
    <tr>
        <td></td> <td>hexfloat</td> <td>浮点值显示为16进制</td>
    </tr>
    <tr>
        <td></td> <td>defaultfloat</td> <td>重置浮点值为10进制</td>
    </tr>
    <tr>
        <td></td> <td>unitbuf</td> <td>每次输出后都刷新缓冲区</td>
    </tr>
    <tr>
        <td>*</td> <td>nounitbuf</td> <td>恢复正常的缓冲区刷新方式</td>
    </tr>
    <tr>
        <td>*</td> <td>skipws</td> <td>输入运算符跳过空白符</td>
    </tr>
    <tr>
        <td></td> <td>noskipws</td> <td>输入运算符不跳过空白符</td>
    </tr>
    <tr>
        <td></td> <td>flush</td> <td>刷新ostream缓冲区</td>
    </tr>
    <tr>
        <td></td> <td>ends</td> <td>插入空白符，然后刷新缓冲区</td>
    </tr>
    <tr>
        <td></td> <td>endl</td> <td>插入换行符，然后刷新缓冲区</td>
    </tr>
</table>

### 17.5.2 未格式化的输入/输出操作
### 17.5.3 流随机访问
由于istream和ostream类型不支持随机访问，所以本节的内容只适用于fstream和sstream类型。





## 第17章 练习题
### 17.1.1节练习
<b>练习17.1</b> 定义一个保存3个int值的tuple，并将其成员分别初始化为10、20和30。

<b>练习17.2</b> 定义一个tuple，保存一个string、一个vector<string>和一个pair<string, int>。

<b>练习17.3</b> 重写12.3节(第430页)中的TextQuery程序，使用tuple代替QueryReault类。你认为哪种设计更好？为什么？

### 17.1.2节练习
<b>练习17.4</b> 编写并测试你自己版本的findBook函数

<b>练习17.5</b> 重写findBook，令其返回一个pair，包含一个索引和一个迭代器pair。

<b>练习17.6</b> 重写findBook，不使用tuple或pair。

<b>练习17.7</b> 解释你更倾向于哪个版本的findBook，为什么？

<b>练习17.8</b> 在本节最后一段代码中，如果我们将Sales_data()作为第3个参数传递给accumulate，会发生什么？

### 17.2.1节练习
<b>练习17.9</b> 解释下列每个bitset对象所包含的位模式：
```text
(a) bitset<64> bitvec(32);
(b) bitset<32> bv(1010101);
(c) string bstr; cin >> bstr; bitset<8> bv(bstr);
```

### 17.2.2节练习
<b>练习17.10</b> 使用序列1、2、3、5、8、13、21初始化一个bitset，将这些位置置位。对另一个bitset进行默认初始化，并编写一小段程序将其恰当的位置置为1。

<b>练习17.11</b> 定义一个数据结构，包含一个整型对象，记录一个包含10个问题的真/假测验的解答。如果测验包含100道题，你需要对数据结构做出什么改变（如果需要的话）？

<b>练习17.12</b> 使用前一题中的数据结构，编写一个函数，它接受一个问题编号和一个表示真/假解答的值，函数根据这2个参数更新测验的解答。

<b>练习17.13</b> 编写一个整型对象，包含真/假测验的正确答案。使用它来为前2题中的数据结构生成测验成绩。


### 17.3.1节练习
<b>练习17.14</b> 编写几个正则表达式，分别触发不同错误。运行牛逼的程序，观察编译器对每个错误的输出。

<b>练习17.15</b> 编写程序，使用模式查找违反"i在e之前，除非在c之后"规则的单词。你的程序应该提示用户输入一个单词，然后指出此单词是否符合要求。用一些
违反和未违反规则的单词测试你的程序。

<b>练习17.16</b> 如果前一题程序中的regex对象用"[^c]ei"进行初始化，将会发生什么？用此模式测试你的程序，检查你的答案是否正确。


### 17.3.2节练习
<b>练习17.17</b> 更新你的程序，令它查找输入序列中所有违反"ei"语法规则的单词。

<b>练习17.18</b> 修改你的程序，忽略包含"ei"但并非拼写错误的单词，如"albeit"和"neighbor"。


### 17.3.3节练习
<b>练习17.19</b> 为什么可以不先检查m[4]是否匹配了就直接调用m[4].str()？

<b>练习17.20</b> 编写你自己版本的验证电话号码的程序。

<b>练习17.21</b> 使用本节中定义的valid函数重写8.3.2(第289页)中额电话号码程序。

<b>练习17.22</b> 重写你的电话号码程序，使之允许在号码的3个部分之间放置任意多个空白符。

<b>练习17.23</b> 编写查找邮政编码的正则表达式。一个美国邮政编码可以由5位或9位数字组成。前5位数字和后4位数字之间可以用一个短横线分隔。


### 17.3.4节练习
<b>练习17.24</b> 编写你自己版本的重排电话号码格式的程序。

<b>练习17.25</b> 重写你的电话号码程序，使之只输出每个人的第一个电话号码。

<b>练习17.26</b> 重写你的电话号码程序，使之对多于一个电话号码的人只输出第二个和后续电话号码。

<b>练习17.27</b> 编写程序，将九位数字邮政编码的格式转换为`ddddd-dddd`。


### 17.4.1节练习
<b>练习17.28</b> 编写函数，每次调用生成并返回一个均匀分布的随机unsigned int。

<b>练习17.29</b> 修改上一题中编写的函数，允许用户提供一个种子作为可选参数。

<b>练习17.30</b> 再次修改你的程序，此次再增加2个参数，表示函数允许返回的最小值和最大值。


### 17.4.2节练习
<b>练习17.31</b> 对于本节中的游戏程序，如果在do循环内定义b和e，会发生什么？

<b>练习17.32</b> 如果我们在循环内定义resp，会发生什么？

<b>练习17.33</b> 修改11.3.6节(第392页)中的单词转换程序，允许对一个给定单词有多种转换方式，每次随机选择一种进行实际转换。


### 17.5.1节练习
<b>练习17.34</b> 编写一个程序，展示如何使用表17.17和表17.18中的每个操作符。

<b>练习17.35</b> 修改第670页中的程序，打印2的平方根，但这次打印16进制数字的大写形式。

<b>练习17.36</b> 修改上一题中的程序，打印不同的浮点数，使它们排成一列。


### 17.5.2节练习
<b>练习17.37</b> 用未格式化版本的getline逐行读取一个文件。测试你的程序，给它一个文件，既包含空行又包含长度超过你传递给getline的字符数组大小的行。

<b>练习17.38</b> 扩展上一题中你的程序，将读入的每个单词打印到它所在的行。


### 17.5.3节练习
<b>练习17.39</b> 对本节给出的seek程序，编写你自己的版本。
