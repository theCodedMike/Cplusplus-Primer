# 第17章 标准库特殊设施
## 17.1 tuple类型
### 17.1.1 定义和初始化tuple
由于`tuple`定义了`<`和`==`运算符，所以可以作为**有序容器**的key。

### 17.1.2 使用tuple返回多个值

## 17.2 bitset类型
### 17.2.1 定义和初始化bitset
### 17.2.2 bitset操作

## 17.3 正则表达式
### 17.3.1 使用正则表达式库
<table>
    <th colspan="2">表17.8 正则表达式库类</th>
    <tr>
        <td><b>如果输入序列类型</b></td> <td><b>则使用正则表达式类</b></td>
    </tr>
    <tr>
        <td>string</td> <td>regex、smatch、ssub_match、sregex_iterator</td>
    </tr>
    <tr>
        <td>const char*</td> <td>regex、cmatch、csub_match、cregex_iterator</td>
    </tr>
    <tr>
        <td>wstring</td> <td>wregex、wsmatch、wssub_match、wsregex_iterator</td>
    </tr>
    <tr>
        <td>const wchar_t*</td> <td>wregex、wcmatch、wcsub_match、wcregex_iterator</td>
    </tr>
</table>

### 17.3.2 匹配与Regex迭代器类型
### 17.3.3 使用子表达式
### 17.3.4 使用regex_replace

## 17.4 随机数
### 17.4.1 随机数引擎和分布
### 17.4.2 其他随机数分布

## 17.5 IO库再探
### 17.5.1 格式化输入与输出
### 17.5.2 未格式化的输入/输出操作
### 17.5.3 流随机访问






## 第17章 练习题
### 17.1.1节练习
<b>练习17.1</b> 定义一个保存3个int值的tuple，并将其成员分别初始化为10、20和30。

<b>练习17.2</b> 定义一个tuple，保存一个string、一个vector<string>和一个pair<string, int>。

<b>练习17.3</b> 重写12.3节(第430页)中的TextQuery程序，使用tuple代替QueryReault类。你认为哪种设计更好？为什么？

### 17.1.2节练习
<b>练习17.4</b> 编写并测试你自己版本的findBook函数

<b>练习17.5</b> 重写findBook，令其返回一个pair，包含一个索引和一个迭代器pair。

<b>练习17.6</b> 重写findBook，不使用tuple或pair。

<b>练习17.7</b> 解释你更倾向于哪个版本的findBook，为什么？

<b>练习17.8</b> 在本节最后一段代码中，如果我们将Sales_data()作为第3个参数传递给accumulate，会发生什么？

### 17.2.1节练习
<b>练习17.9</b> 解释下列每个bitset对象所包含的位模式：
```text
(a) bitset<64> bitvec(32);
(b) bitset<32> bv(1010101);
(c) string bstr; cin >> bstr; bitset<8> bv(bstr);
```

### 17.2.2节练习
<b>练习17.10</b> 使用序列1、2、3、5、8、13、21初始化一个bitset，将这些位置置位。对另一个bitset进行默认初始化，并编写一小段程序将其恰当的位置置为1。

<b>练习17.11</b> 定义一个数据结构，包含一个整型对象，记录一个包含10个问题的真/假测验的解答。如果测验包含100道题，你需要对数据结构做出什么改变（如果需要的话）？

<b>练习17.12</b> 使用前一题中的数据结构，编写一个函数，它接受一个问题编号和一个表示真/假解答的值，函数根据这2个参数更新测验的解答。

<b>练习17.13</b> 编写一个整型对象，包含真/假测验的正确答案。使用它来为前2题中的数据结构生成测验成绩。


### 17.3.1节练习
<b>练习17.14</b> 编写几个正则表达式，分别触发不同错误。运行牛逼的程序，观察编译器对每个错误的输出。

<b>练习17.15</b> 编写程序，使用模式查找违反"i在e之前，除非在c之后"规则的单词。你的程序应该提示用户输入一个单词，然后指出此单词是否符合要求。用一些
违反和未违反规则的单词测试你的程序。

<b>练习17.16</b> 如果前一题程序中的regex对象用"[^c]ei"进行初始化，将会发生什么？用此模式测试你的程序，检查你的答案是否正确。


### 17.3.2节练习
<b>练习17.17</b> 更新你的程序，令它查找输入序列中所有违反"ei"语法规则的单词。

<b>练习17.18</b> 修改你的程序，忽略包含"ei"但并非拼写错误的单词，如"albeit"和"neighbor"。


### 17.3.3节练习
<b>练习17.19</b> 为什么可以不先检查m[4]是否匹配了就直接调用m[4].str()？

<b>练习17.20</b> 编写你自己版本的验证电话号码的程序。

<b>练习17.21</b> 使用本节中定义的valid函数重写8.3.2(第289页)中额电话号码程序。

<b>练习17.22</b> 重写你的电话号码程序，使之允许在号码的3个部分之间放置任意多个空白符。

<b>练习17.23</b> 编写查找邮政编码的正则表达式。一个美国邮政编码可以由5位或9位数字组成。前5位数字和后4位数字之间可以用一个短横线分隔。


### 17.3.4节练习
<b>练习17.24</b> 编写你自己版本的重排电话号码格式的程序。

<b>练习17.25</b> 重写你的电话号码程序，使之只输出每个人的第一个电话号码。

<b>练习17.26</b> 重写你的电话号码程序，使之对多于一个电话号码的人只输出第二个和后续电话号码。

<b>练习17.27</b> 编写程序，将九位数字邮政编码的格式转换为`ddddd-dddd`。

























