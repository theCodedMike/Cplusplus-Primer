# 第18章 用于大型程序的工具
## 18.1 异常处理
### 18.1.1 抛出异常
### 18.1.2 捕获异常
最好将catch的参数定义成引用类型。

如果在多个catch语句的类型之间存在继承关系，则我们应该把继承链最低端的类放在前面，把最顶端的类放在后面。

空的throw语句(throw;)只能出现在catch语句或catch语句直接或间接调用的函数之内。

只有当catch异常声明是引用类型时我们对参数所做的改变才会被保留并继续传播。

`catch(...)`可以捕获所有异常，既能单独出现，也能与其他几个catch一起出现(此时须出现在最后)。
### 18.1.3 函数try语句块与构造函数
处理构造函数初始值异常的唯一方法时将构造函数写出函数try语句块。

### 18.1.4 noexcept异常说明
```c++
void recout(int) throw();        // 不会抛出异常
void recoup(int) noexcept;       // 不会抛出异常
void recoup(int) noexcept(true); // 不会抛出异常
void alloc(int);                 // 可能抛出异常
void alloc(int) noexcept(false); // 可能抛出异常
```
在成员函数中，noexcept说明符需跟在const及引用限定符之后，而在final、override或虚函数=0之前。

如果一个虚函数承诺它不会抛出异常，则后续派生出的虚函数也必须承诺不会抛出异常；如果基类的虚函数允许抛出异常，则派生类的对应函数可以抛出异常，也可以不抛出异常。

### 18.1.5 异常类层次
```text
                exception
              /   /    \   \
       bad_cast  /      \  bad_alloc
       runtime_error  logic_error
                  |    |
  overflow_error -|    |- domain-error 
 underflow_error -|    |- invalid_argument
     range_error -|    |- out_of_range
                       |- length_error
```


## 18.2 命名空间
### 18.2.1 命名空间定义
### 18.2.2 使用命名空间
### 18.2.3 类、命名空间与作用域
### 18.2.4 重载与命名空间

## 18.3 多重继承与虚继承
### 18.3.1 多重继承
### 18.3.2 类型转换与多个基类
### 18.3.3 多重继承下的类作用域
### 18.3.4 虚继承
### 18.3.5 构造函数与虚继承
















## 第18章 练习题
### 18.1.1节练习
<b>练习18.1</b> 在下列throw语句中异常对象的类型是什么？
```text
(a) range_error r("error");        (b) exception *p = &r;
    throw r;                           throw *p;
```
如果将(b)中的throw语句写成了throw p将会发生什么情况？
<b>练习18.2</b> 当在指定位置发生了异常时将出现什么情况？
```c++
void exercise(int *b, int *e) {
    vector<int> v(b, e);
    int *p = new int[v.size()];
    ifstream in("ints");
    // 此处发生异常
}
```
<b>练习18.3</b> 要想让上面的代码在发生异常时能正常工作，有2种解决方案。请描述这2种方法并实现它们。


### 18.1.2节练习
<b>练习18.4</b> 查看图18.1(第693页)所示的继承体系，说明下面的try块有何错误并修改它。
```c++
try {
    // 使用C++标准库
} catch (exception) {
    // ...
} catch (const runtime_error &re) {
    // ...
} catch (overflow_error eobj) {
    /* ... */
}
```
<b>练习18.5</b> 修改下面的main函数，使其能捕获图18.1(第693页)所示的任何异常类型：
```c++
int main() {
    // 使用C++标准库
}
```
处理代码应该首先打印异常相关的错误信息，然后调用abort(定义在cstdlib头文件种)终止main函数。
<b>练习18.6</b> 已知下面的异常类型和catch语句，书写一个throw表达式使其创建的异常对象能被这些catch语句捕获：
```text
(a) class exceptionType { };
    catch (exceptionType *pet) { }
(b) catch(...) { }
(c) typedef int EXCPTYPE;
    catch (EXCPTYPE) { }
```

### 18.1.3节练习
<b>练习18.7</b> 根据第16章的介绍定义你自己的Blob和BlobPtr，注意将构造函数写出函数try语句块。


### 18.1.4节练习
<b>练习18.8</b> 回顾你之前编写的各个类，为它们的构造函数和析构函数添加正确的异常说明。如果你认为某个析构函数可能抛出异常，尝试修改代码使得该析构函数
不会抛出异常。


### 18.1.5节练习
<b>练习18.9</b> 定义本节描述的书店程序异常类，然后为Sales_data类重新编写一个复合赋值运算符并令其抛出一个异常。

<b>练习18.10</b> 编写程序令其对2个ISBN编号不同的对象执行Sales_data的加法运算。为该程序编写2个不同的版本：一个处理异常，另一个不处理异常。观察
并比较这2个程序的行为，用心体会当出现了一个未被捕获的异常时程序会发生什么情况。

<b>练习18.11</b> 为什么what函数不应该抛出异常？

