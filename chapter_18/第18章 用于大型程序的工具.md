# 第18章 用于大型程序的工具
## 18.1 异常处理
### 18.1.1 抛出异常
### 18.1.2 捕获异常
最好将catch的参数定义成引用类型。

如果在多个catch语句的类型之间存在继承关系，则我们应该把继承链最低端的类放在前面，把最顶端的类放在后面。

空的throw语句(throw;)只能出现在catch语句或catch语句直接或间接调用的函数之内。

只有当catch异常声明是引用类型时我们对参数所做的改变才会被保留并继续传播。

`catch(...)`可以捕获所有异常，既能单独出现，也能与其他几个catch一起出现(此时须出现在最后)。
### 18.1.3 函数try语句块与构造函数
处理构造函数初始值异常的唯一方法时将构造函数写出函数try语句块。

### 18.1.4 noexcept异常说明
```c++
void recout(int) throw();        // 不会抛出异常
void recoup(int) noexcept;       // 不会抛出异常
void recoup(int) noexcept(true); // 不会抛出异常
void alloc(int);                 // 可能抛出异常
void alloc(int) noexcept(false); // 可能抛出异常
```
在成员函数中，noexcept说明符需跟在const及引用限定符之后，而在final、override或虚函数=0之前。

如果一个虚函数承诺它不会抛出异常，则后续派生出的虚函数也必须承诺不会抛出异常；如果基类的虚函数允许抛出异常，则派生类的对应函数可以抛出异常，也可以不抛出异常。

### 18.1.5 异常类层次
```text
                exception
              /   /    \   \
       bad_cast  /      \  bad_alloc
       runtime_error  logic_error
                  |    |
  overflow_error -|    |- domain-error 
 underflow_error -|    |- invalid_argument
     range_error -|    |- out_of_range
                       |- length_error
```


## 18.2 命名空间
### 18.2.1 命名空间定义
### 18.2.2 使用命名空间
### 18.2.3 类、命名空间与作用域
### 18.2.4 重载与命名空间
using声明语句声明的是一个名字，而非一个特定的函数。


## 18.3 多重继承与虚继承
### 18.3.1 多重继承
### 18.3.2 类型转换与多个基类
### 18.3.3 多重继承下的类作用域
### 18.3.4 虚继承
### 18.3.5 构造函数与虚继承
















## 第18章 练习题
### 18.1.1节练习
<b>练习18.1</b> 在下列throw语句中异常对象的类型是什么？
```text
(a) range_error r("error");        (b) exception *p = &r;
    throw r;                           throw *p;
```
如果将(b)中的throw语句写成了throw p将会发生什么情况？
<b>练习18.2</b> 当在指定位置发生了异常时将出现什么情况？
```c++
void exercise(int *b, int *e) {
    vector<int> v(b, e);
    int *p = new int[v.size()];
    ifstream in("ints");
    // 此处发生异常
}
```
<b>练习18.3</b> 要想让上面的代码在发生异常时能正常工作，有2种解决方案。请描述这2种方法并实现它们。


### 18.1.2节练习
<b>练习18.4</b> 查看图18.1(第693页)所示的继承体系，说明下面的try块有何错误并修改它。
```c++
try {
    // 使用C++标准库
} catch (exception) {
    // ...
} catch (const runtime_error &re) {
    // ...
} catch (overflow_error eobj) {
    /* ... */
}
```
<b>练习18.5</b> 修改下面的main函数，使其能捕获图18.1(第693页)所示的任何异常类型：
```c++
int main() {
    // 使用C++标准库
}
```
处理代码应该首先打印异常相关的错误信息，然后调用abort(定义在cstdlib头文件种)终止main函数。
<b>练习18.6</b> 已知下面的异常类型和catch语句，书写一个throw表达式使其创建的异常对象能被这些catch语句捕获：
```text
(a) class exceptionType { };
    catch (exceptionType *pet) { }
(b) catch(...) { }
(c) typedef int EXCPTYPE;
    catch (EXCPTYPE) { }
```

### 18.1.3节练习
<b>练习18.7</b> 根据第16章的介绍定义你自己的Blob和BlobPtr，注意将构造函数写出函数try语句块。


### 18.1.4节练习
<b>练习18.8</b> 回顾你之前编写的各个类，为它们的构造函数和析构函数添加正确的异常说明。如果你认为某个析构函数可能抛出异常，尝试修改代码使得该析构函数
不会抛出异常。


### 18.1.5节练习
<b>练习18.9</b> 定义本节描述的书店程序异常类，然后为Sales_data类重新编写一个复合赋值运算符并令其抛出一个异常。

<b>练习18.10</b> 编写程序令其对2个ISBN编号不同的对象执行Sales_data的加法运算。为该程序编写2个不同的版本：一个处理异常，另一个不处理异常。观察
并比较这2个程序的行为，用心体会当出现了一个未被捕获的异常时程序会发生什么情况。

<b>练习18.11</b> 为什么what函数不应该抛出异常？


### 18.2.1节练习
<b>练习18.12</b> 将你为之前各章练习编写的程序放置在各自的命名空间中。也就是说，命名空间chapter15包含Query程序的代码，命名空间chapter10包含TextQuey
的代码：使用这种结构重新编译Query代码示例。

<b>练习18.13</b> 什么时候应该使用为命名的命名空间？

<b>练习18.14</b> 假设下面的operator*声明的是嵌套的命名空间mathLib::MatrixLib的一个成员：
```c++
namespace mathLib {
    namespace MatrixLib {
        class matrix { /* ... */ }
        matrix operator*(const matrix &, const matrix &);
        // ...
    }
}
```
请问你应该如何在全局作用域中声明该运算符？


### 18.2.2节练习
<b>练习18.15</b> 说明using指示与using声明的区别。

<b>练习18.16</b> 假定在下面的代码中标记为"位置1"的地方是对于命名空间Exercise中所有成员的using声明，请解释代码的含义。如果这些using声明出现在
"位置2"又会怎样呢？将using声明变为using指示，重新回答之前的问题。
```c++
namespace Exercise {
    int ivar = 0;
    double dvar = 0;
    const int limit = 1000;
}
int ivar = 0;
// 位置1
void manip() {
    // 位置2
    double dvar = 3.1416;
    int iobj = limit + 1;
    ++ivar;
    ++::ivar;
}
```
<b>练习18.17</b> 实际编写代码检验你对上一题的回答是否正确。


### 18.2.3节练习
<b>练习18.18</b> 已知有下面的swap的典型定义(参见13.3节，第457页)，当meml是一个string时程序使用swap的哪个版本？如果meml是int呢？
说明在这2种情况下名字查找的过程。
```c++
void swap(T v1, T v2) {
    using std::swap;
    swap(v1.meml, v2.meml);
    // 交换类型T的其他成员
}
```
<b>练习18.19</b> 如果对swap的调用形如std::swap(v1.meml, v2.meml)将发生什么情况？


### 18.2.4节练习
<b>练习18.20</b> 在下面的代码中，确定哪个函数与compute调用匹配。列出所有候选函数和可行函数，对于每个可行函数的实参与形参的匹配过程来说，发生了哪种类型转换？
```c++
namespace primerLib {
    void compute();
    void compute(const void *);
}
using primerLib::compute;
void compute(int);
void compute(double, double = 3.4);
void compute(char*, char* = 0);
void f() {
    compute(0);
}
```
如果将using声明置于main函数中compute的调用点之前将发生什么情况？重新回答之前的那些问题。




