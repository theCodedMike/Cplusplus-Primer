# 第15章 面向对象程序设计
## 15.1 OOP: 概述
**面向对象程序设计**(object-oriented programming)的核心思想是*数据抽象*、*继承*和*动态绑定*。

在C++语言中，当我们使用基类的引用(或指针)调用一个虚函数时将发生*动态绑定*。

## 15.2 定义基类和派生类
### 15.2.1 定义基类
基类通常都应该定义一个虚析构函数，即使该函数不执行任何实际操作。

如果基类把一个函数声明成虚函数，则该函数在派生类中隐式地也是虚函数。

### 15.2.2 定义派生类
大多数类都只继承自一个类，这种形式的继承被称作**单继承**。

一个类不能派生它自身。

派生类可以访问基类的共有成员和受保护成员。

在类名后跟一个关键字`final`可以防止该类被继承。
### 15.2.3 类型转换与继承
和内置指针一样，智能指针类也支持派生类向基类的类型转换。

当我们用一个派生类对象为一个基类对象初始化或赋值时，只有该派生类对象中的基类部分会被拷贝、移动或赋值，派生类部分会被忽略掉。

从派生类向基类的类型转换只对指针或引用类型有效。
## 15.3 虚函数

## 15.4 抽象基类

## 15.5 访问控制与继承

## 15.6 继承中的类作用域

## 15.7 构造函数与拷贝控制
### 15.7.1 虚析构函数
### 15.7.2 合成拷贝控制与继承
### 15.7.3 派生类的拷贝控制成员
### 15.7.4 继承的构造函数

## 15.8 容器与继承
### 15.8.1 编写Basket类

## 15.9 文本查询程序再探
### 15.9.1 面向对象的解决方案
### 15.9.2 Query_base类和Query类
### 15.9.3 派生类
### 15.9.4 eval函数








## 第15章 练习题
### 15.2.1节练习
<b>练习15.1</b> 什么是虚成员？

<b>练习15.2</b> protected访问说明符与private有何区别？

<b>练习15.3</b> 定义你自己的Quote类和print_total函数。

### 15.2.2节练习
<b>练习15.4</b> 下面哪条声明语句是不正确的？解释原因
```text
class Base { ... };
(a) class Derived : public Derived { ... };
(b) class Derived : private Base { ... };
(c) class Derived : public Base;
```
<b>练习15.5</b> 定义你自己的Bulk_quote类。

<b>练习15.6</b> 将Quote和Bulk_quote的对象传给15.2.1节(第529页)练习中的print_total函数，检查该函数是否正确。

<b>练习15.7</b> 定义一个类使其实现一种数量受限的折扣策略，具体策略是：当购买书籍的数量不超过一个给定的限量时享受折扣，如果购买量一旦超过了限量，则
超出的部分将以原价销售。


### 15.2.3节练习
<b>练习15.8</b> 给出静态类型和动态类型的定义。

<b>练习15.9</b> 在什么情况下表达式的静态类型可能与动态类型不同？请给出3个静态类型与动态类型不同的例子。

<b>练习15.10</b> 回忆我们在8.1节进行的讨论，解释第284页中将ifstream传递给Sales_data的read函数的程序是如何工作的。







