# 第15章 面向对象程序设计
## 15.1 OOP: 概述
**面向对象程序设计**(object-oriented programming)的核心思想是*数据抽象*、*继承*和*动态绑定*。

在C++语言中，当我们使用基类的引用(或指针)调用一个虚函数时将发生*动态绑定*。

## 15.2 定义基类和派生类
### 15.2.1 定义基类
基类通常都应该定义一个虚析构函数，即使该函数不执行任何实际操作。

如果基类把一个函数声明成虚函数，则该函数在派生类中隐式地也是虚函数。

### 15.2.2 定义派生类
大多数类都只继承自一个类，这种形式的继承被称作**单继承**。

一个类不能派生它自身。

派生类可以访问基类的共有成员和受保护成员。

在类名后跟一个关键字`final`可以防止该类被继承；如果一个成员函数被声明为final，则该函数不能被重写。
### 15.2.3 类型转换与继承
和内置指针一样，智能指针类也支持派生类向基类的类型转换。

当我们用一个派生类对象为一个基类对象初始化或赋值时，只有该派生类对象中的基类部分会被拷贝、移动或赋值，派生类部分会被忽略掉。

从派生类向基类的类型转换只对指针或引用类型有效。
## 15.3 虚函数
如果虚函数使用默认实参，则基类和派生类中定义的默认实参最好一致。

## 15.4 抽象基类
含有纯虚函数的类是抽象基类

不能直接创建一个抽象基类的对象，抽象基类负责定义接口，继承的类可以覆盖该接口。

派生类必须实现所有纯虚函数，否则它也将成为抽象类。

## 15.5 访问控制与继承
派生类的成员或友元只能通过派生类对象来访问基类的受保护成员。

默认情况下，使用class关键字定义的派生类是私有继承的，使用struct关键字定义的派生类是公有继承的。

## 15.6 继承中的类作用域

## 15.7 构造函数与拷贝控制
### 15.7.1 虚析构函数
### 15.7.2 合成拷贝控制与继承
### 15.7.3 派生类的拷贝控制成员
如果构造函数或析构函数调用了某个虚函数，则我们应该执行与构造函数或析构函数所属类型相对应的虚函数版本。

### 15.7.4 继承的构造函数

## 15.8 容器与继承
在容器中存放具有继承关系的对象时，应该存放的是基类的智能指针。
### 15.8.1 编写Basket类

## 15.9 文本查询程序再探
### 15.9.1 面向对象的解决方案
### 15.9.2 Query_base类和Query类
### 15.9.3 派生类
### 15.9.4 eval函数








## 第15章 练习题
### 15.2.1节练习
<b>练习15.1</b> 什么是虚成员？

<b>练习15.2</b> protected访问说明符与private有何区别？

<b>练习15.3</b> 定义你自己的Quote类和print_total函数。

### 15.2.2节练习
<b>练习15.4</b> 下面哪条声明语句是不正确的？解释原因
```text
class Base { ... };
(a) class Derived : public Derived { ... };
(b) class Derived : private Base { ... };
(c) class Derived : public Base;
```
<b>练习15.5</b> 定义你自己的Bulk_quote类。

<b>练习15.6</b> 将Quote和Bulk_quote的对象传给15.2.1节(第529页)练习中的print_total函数，检查该函数是否正确。

<b>练习15.7</b> 定义一个类使其实现一种数量受限的折扣策略，具体策略是：当购买书籍的数量不超过一个给定的限量时享受折扣，如果购买量一旦超过了限量，则
超出的部分将以原价销售。


### 15.2.3节练习
<b>练习15.8</b> 给出静态类型和动态类型的定义。

<b>练习15.9</b> 在什么情况下表达式的静态类型可能与动态类型不同？请给出3个静态类型与动态类型不同的例子。

<b>练习15.10</b> 回忆我们在8.1节进行的讨论，解释第284页中将ifstream传递给Sales_data的read函数的程序是如何工作的。


### 15.3节练习
<b>练习15.11</b> 为你的Quote类体系添加一个名为debug的虚函数，令其分别显式每个类的数据成员。

<b>练习15.12</b> 有必要将一个成员函数同时声明成override和final吗？为什么？

<b>练习15.13</b> 给定下面的类，解释每个print函数的机理：
```c++
class base {
public:
    string name() { return basename; }
    virtual void print(ostream &os) { os << basename; }
private:
    string basename;
};

class derived : public base {
public:
    void print(ostream &os) { print(os); os << " " << i; }
private:
    int i;
};
```
上述的代码有问题吗？如果有，如何修改它。

<b>练习15.14</b> 给定上一题中的类以及下面这些对象，说明在运行时调用哪个函数：
```text
base bobj;        base *bp1 = &bobj;        base &br1 = bobj;
derived dobj;     base *bp2 = &dobj;        base &br2 = dobj;

(a) bobj.print();           (b) dobj.print();           (c) bp1->name();
(d) bp2->name();            (e) br1.print();            (f) br2.print();
```

### 15.4节练习
<b>练习15.15</b> 定义你自己的Disc_quote和Bulk_quote。

<b>练习15.16</b> 改写你在15.2.2节练习中编写的数量受限的折扣策略，令其继承Disc_quote类。

<b>练习15.17</b> 尝试定义一个Disc_quote的对象，看看编译器给出的错误信息是什么？

### 15.5节练习
<b>练习15.18</b> 假设给定了第543页和第544页的类，同时已知每个对象的类型如注释所示，判断下面的哪些赋值语句是合法的。解释那些不合法的语句为什么不被允许：
```c++
Base *p = &d1; // d1的类型是Pub_Derv
p = &d2;       // d2的类型是Priv_Derv
p = &d3;       // d3的类型是Prot_Derv
p = &dd1;      // dd1的类型是Derived_from_Public
p = &dd2;      // dd2的类型是Derived_from_Private
p = &dd3;      // dd3的类型是Derived_from_Protected
```
<b>练习15.19</b> 假设543页和544页的每个类都有如下形式的成员函数：
```c++
void memfcn(Base &b) { b = *this; }
```
对于每个类，分别判断上面的函数是否合法。
<b>练习15.20</b> 编写代码检验你对前面2题的回答是否正确。

<b>练习15.21</b> 从下面这些一般性抽象概念中人选一个（或者选一个你自己的），将其对应的一组类型组织成一个继承体系：
```text
(a) 图形文件格式（如gif、tiff、jpeg、bmp）
(b) 图形基元（如方格、园、球、圆锥）
(c) C++语言中的类型（如类、函数、成员函数）
```
<b>练习15.22</b> 对于你在上一题中选择的类，为其添加合适的虚函数及公有成员和受保护的成员。

### 15.6节练习
<b>练习15.23</b> 假设第550页的D1类需要覆盖它继承而来的fcn函数，你应该如何对其进行修改？如果你修改之后fcn匹配了Base中的定义，则该节的那些调用语句该如何解析？

### 15.7.1节练习
<b>练习15.24</b> 哪种类需要虚析构函数？虚析构函数必须执行什么样的操作？

### 15.7.2节练习
<b>练习15.25</b> 我们为什么为Disc_quote定义一个默认构造函数？如果去掉，会对Bulk_quote的行为产生什么影响?

### 15.7.3节练习
<b>练习15.26</b> 定义Quote和Bulk_quote的拷贝控制成员，令其与合成的版本行为一致。为这些成员以及其他构造函数添加打印状态的语句，
使得我们能够知道正在运行哪个程序。使用这些类编写程序，预测程序将创建和销毁哪些对象。重复实验，不断比较你的预测和实际输出结果是否相同，
知道预测完全准确再结束。

### 15.7.4节练习
<b>练习15.27</b> 重新定义你的Bulk_quote类，令其继承构造函数。

### 15.8节练习
<b>练习15.28</b> 定义一个存放Quote对象的vector，将Bulk_quote对象传入其中。计算vector中所有元素总的price。

<b>练习15.29</b> 再运行一次你的程序，这次传入Quote对象的shared_ptr。如果这次计算出的总额与之前的程序不一致，解释为什么；如果一致，请说明原因。

### 15.8.1节练习
<b>练习15.30</b> 编写你自己的Basket类，用它计算上一个练习中交易记录的总价格。





