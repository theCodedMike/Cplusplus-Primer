# 第11章 关联容器
<table>
    <tr>
        <th colspan="2">表11.1 关联容器类型</th>
    </tr>
    <tr>
        <td><b>按关键字有序保存元素</b></td>
    </tr>
    <tr>
        <td>map</td> <td>关联数组；保存关键字-值对</td>
    </tr>
    <tr>
        <td>set</td> <td>只保存关键字</td>
    </tr>
    <tr>
        <td>multimap</td> <td>关键字可重复出现的map</td>
    </tr>
    <tr>
        <td>multiset</td> <td>关键字可重复出现的set</td>
    </tr>
    <tr>
        <td><b>无序集合</b></td>
    </tr>
    <tr>
        <td>unordered_map</td> <td>用哈希函数组织的map</td>
    </tr>
    <tr>
        <td>unordered_set</td> <td>用哈希函数组织的set</td>
    </tr>
    <tr>
        <td>unordered_multimap</td> <td>哈希组织的map；关键字可以重复出现</td>
    </tr>
    <tr>
        <td>unordered_multiset</td> <td>哈希组织的set；关键字可以重复出现</td>
    </tr>
</table>

## 11.1 使用关联容器

## 11.2 关联容器概述
关联容器的迭代器都是双向的
### 11.2.1 定义关联容器
### 11.2.2 关键字类型的要求
如果一个类型支持`<`运算，则它可以用作关键字类型
### 11.2.3 pair类型
<table>
    <tr>
        <th colspan="2">表11.2 pair上的操作</th>
    </tr>
    <tr>
        <td>pair'<'T1 T2'>' p</td> <td>p是一个pair，2个类型分别是T1和T2</td>
    </tr>
    <tr>
        <td>pair'<'T1 T2'>' p(v1, v2)</td> <td></td>
    </tr>
    <tr>
        <td>pair'<'T1 T2'>' p = {v1, v2}</td> <td></td>
    </tr>
    <tr>
        <td>make_pair(v1, v2)</td> <td>返回一个用v1和v2初始化的pair</td>
    </tr>
    <tr>
        <td>p.first</td> <td>返回p的名为first的公有数据成员</td>
    </tr>
    <tr>
        <td>p.second</td> <td>返回p的名为second的公有数据成员</td>
    </tr>
    <tr>
        <td>p1 rela p2</td> <td>rela表示<、<=、>、>=、==、!=</td>
    </tr>
</table>

## 11.3 关联容器操作
<table>
    <tr>
        <th colspan="2">表11.3 关联容器额外的类型别名</th>
    </tr>
    <tr>
        <td>key_type</td> <td>关键字的类型</td>
    </tr>
    <tr>
        <td>mapped_type</td> <td>关键字映射的值的类型</td>
    </tr>
    <tr>
        <td>value_type</td> <td>对于set，与key_type相同；对于map，是pair`<`const key_type, mapped_type></td>
    </tr>
</table>

map的key不能改变，mapped的值可以改变。

set的key不能改变。

### 11.3.1 关联容器迭代器
### 11.3.2 添加元素
<table>
    <tr>
        <th>表11.4 关联容器insert操作</th>
    </tr>
    <tr>
        <td>c.insert(val)</td> <td>val是value_type的实例</td>
    </tr>
    <tr>
        <td>c.emplace(args)</td> <td></td>
    </tr>
    <tr>
        <td>c.insert(beg, end)</td> <td>beg和end表示一个c::value_type类型值的范围</td>
    </tr>
    <tr>
        <td>c.insert(init_list)</td> <td>init_list表示一个花括号列表</td>
    </tr>
    <tr>
        <td>c.insert(pos, val)</td> <td></td>
    </tr>
    <tr>
        <td>c.emplace(pos, args)</td> <td></td>
    </tr>
</table>

### 11.3.3 删除元素
<table>
    <tr>
        <th colspan="2">表11.5 从关联容器删除元素</th>
    </tr>
    <tr>
        <td>c.erase(k) -> size_type</td> <td>返回删除元素的个数</td>
    </tr>
    <tr>
        <td>c.erase(pos) -> iter_next</td> <td>pos指向c中待删除的元素，返回一个指向pos之后元素的迭代器</td>
    </tr>
    <tr>
        <td>c.erase(beg, end) -> end</td> <td>删除指定范围内的元素，返回end</td>
    </tr>
</table>

### 11.3.4 map的下标操作
<table>
    <tr>
        <th colspan="2">表11.6 map和unordered_map的下标操作</th>
    </tr>
    <tr>
        <td>c[k]</td> <td>返回关键字为k的元素；如果k不在c中，则添加一个关键字为k的元素，对其进行初始化</td>
    </tr>
    <tr>
        <td>c.at(k)</td> <td>访问关键字为k的元素，带参数检查；如果k不在c中，抛出一个out_of_range异常</td>
    </tr>
</table>

### 11.3.5 访问元素
<table>
    <tr>
        <th colspan="2">表11.7 在一个关联容器中查找元素的操作</th>
    </tr>
    <tr>
        <td>c.find(k)</td> <td>返回第一个指向k的元素的迭代器；如果不存在，则返回尾后迭代器</td>
    </tr>
    <tr>
        <td>c.count(k)</td> <td>返回关键字等于k的元素的个数</td>
    </tr>
    <tr>
        <td>c.lower_bound(k)</td> <td>只对有序容器有效，返回第一个不小于k的元素的迭代器</td>
    </tr>
    <tr>
        <td>c.upper_bound(k)</td> <td>只对有序容器有效，返回第一个大于k的元素的迭代器</td>
    </tr>
    <tr>
        <td>c.equal_range(k)</td> <td>只对有序容器有效，返回一个迭代器pair，表示关键字等于k的元素的范围</td>
    </tr>
</table>

### 11.3.6 一个单词转换的map

## 11.4 无序容器



## 第11章 练习题
### 11.1节练习
<b>练习11.1</b> 描述map和vector的不同。

<b>练习11.2</b> 分别给出最适合使用list、vector、deque、map以及set的例子。

<b>练习11.3</b> 编写你自己的单词计数程序。

<b>练习11.4</b> 扩展你的程序，忽略大小写和标点。例如"example."、"example,"和"Example"应该递增相同的计数器。

### 11.2.1节练习
<b>练习11.5</b> 解释map和set的区别。你如何选择使用哪个？

<b>练习11.6</b> 解释set和list的区别。你如何选择使用哪个？

<b>练习11.7</b> 定义一个map，关键字是家庭的姓，值是一个vector，保存家中孩子们的名。编写代码，实现添加新的家庭以及向已有家庭中添加新的孩子。

<b>练习11.8</b> 编写一个程序，在一个vector而不是一个set中保存不重复的单词。使用set的优点是什么？

### 11.2.2节练习
<b>练习11.9</b> 定义一个map，将单词与一个行号的list关联，list中保存的是单词所出现的行号。

<b>练习11.10</b> 可以定义一个vector<int>::iterator到int的map吗？list<int>::iterator到int的map呢？如果不能，为什么？

<b>练习11.11</b> 不使用decltype重新定义bookstore。

### 11.2.3节练习
<b>练习11.12</b> 编写程序，读入string和int的序列，将每个string和int存入一个pair中，pair保存在一个vector中。

<b>练习11.13</b> 在上一题中，至少有3种创建pair的方法。编写此程序的3个版本，分别采用不同的方法创建pair。解释你认为哪种形式最易于编写和理解？

<b>练习11.14</b> 扩展你在11.2.1节练习种编写的孩子姓到名的map，添加一个pair的vector，保存孩子的名的生日。

### 11.3.1节练习
<b>练习11.15</b> 对一个int到vector<int>的map，其mapped_type、key_type和value_type分别是什么？

<b>练习11.16</b> 使用一个map迭代器编写一个表达式，将一个值赋予一个元素。

<b>练习11.17</b> 假定c是一个string的multiset，v是一个string的vector，解释下面的调用。指出每个调用是否合法：
```c++
copy(v.begin(), v.end(), inserter(c, c.end()));
copy(v.begin(), v.end(), back_inserter(c));
copy(c.begin(), c.end(), inserter(v, v.end()));
copy(c.begin(), c.end(), back_inserter(v));
```
<b>练习11.18</b> 写出第382页循环种map_it的类型，不要使用auto或decltype。

<b>练习11.19</b> 定义一个变量，通过对11.2.2节种的名为bookstore的multiset调用begin()来初始化这个变量。写出变量的类型，不要使用auto或decltype。

### 11.3.2节练习
<b>练习11.20</b> 重写11.1节练习的单词计数程序，使用insert代替下标操作。你认为哪个程序更容易编写与阅读？

<b>练习11.21</b> 假定word_count是一个string到size_t的map，word是一个string，解释下面循环的作用：
```c++
while (cin >> word)
    ++word_count.insert({word, 0}).first->second;
```
<b>练习11.22</b> 给定一个map<string, vector<int>>，对此容器的插入一个元素的insert版本，写出其参数类型和返回类型。

<b>练习11.23</b> 11.2.1节练习种的map以孩子的姓为关键字，保存他们的名的vector，用multimap重写此程序。

### 11.3.4节练习
<b>练习11.24</b> 下面的程序完成什么功能？
```c++
map<int, int> m;
m[0] = 1;
```
<b>练习11.25</b> 对比下面程序与上一题程序
```c++
vector<int> v;
v[0] = 1;
```
<b>练习11.26</b> 可以用什么类型来对一个map进行下标操作？下标运算符返回的类型是什么？举出一个具体的例子。

### 11.3.5节练习
<b>练习11.27</b> 对于什么问题你会使用count来解决？什么时候你会选择find呢？

<b>练习11.28</b> 对一个string到int的vector的map，定义并初始化一个变量来保存在其上调用find所返回的结果。

<b>练习11.29</b> 如果给定的关键字不在容器中，upper_bound、lower_bound和equal_range分别会返回什么？

<b>练习11.30</b> 对于本节最后一个程序中的输出表达式，解释运算对象pos.first->second的含义。

<b>练习11.31</b> 编写程序，定义一个作者及其作品的multimap。使用find在multimap中查找一个元素并用erase删除它。确保你的程序在元素不在map中时也能正常运行。

<b>练习11.32</b> 使用上一题定义的multimap编写一个程序，按字典序打印作者列表和他们的作品。

### 11.3.6节练习
<b>练习11.33</b> 实现你自己版本的单词转换程序。

<b>练习11.34</b> 如果你将transform函数中的find替换为下标运算符，会发生什么？

<b>练习11.35</b> 在build_map中，如果进行如下改写，会有什么效果？
```text
   trans_map[key] = value.substr(1);
改为trans_map.insert({key, value.substr(1)});
```
<b>练习11.36</b> 我们的程序并没有检查输入文件的合法性，特别是它假定转换规则文件中的规则都是有意义的。如果文件中的某一行包含一个关键字、一个空格，
然后就结束了，会发生什么？预测程序的行为并进行验证，再与你的程序进行比较。






