# 第12章 动态内存
**静态内存**: 用来保存局部static对象、类static数据成员以及定义在任何函数之外的变量。由编译器自动创建和销毁。

**栈内存**: 用来保存定义在函数内的非static对象。由编译器自动创建和销毁。

**堆内存**: 用来保存动态分配的对象，即在程序运行时分配的对象。由程序来控制创建和销毁。

## 12.1 动态内存与智能指针
### 12.1.1 shared_ptr类
**shared_ptr**: 允许多个指针指向同一个对象。
<table>
    <tr>
        <th colspan="2">表12.1 shared_ptr和unique_ptr都支持的操作</th>
    </tr>
    <tr>
        <td>shared_ptr<·T> sp</td> <td>空智能指针，可以指向类型为T的对象</td>
    </tr>
    <tr>
        <td>unique_ptr<·T> up</td> <td></td>
    </tr>
    <tr>
        <td>p</td> <td>将p用作一个条件判断，若p指向一个对象，则为true</td>
    </tr>
    <tr>
        <td>*p</td> <td>解引用p，获得它指向的对象</td>
    </tr>
    <tr>
        <td>p->mem</td> <td>等价于(*p).mem</td>
    </tr>
    <tr>
        <td>p.get()</td> <td>返回p中保存的指针</td>
    </tr>
    <tr>
        <td>swap(p, q)</td> <td>交换p和q中的指针</td>
    </tr>
    <tr>
        <td>p.swap(q)</td> <td></td>
    </tr>
</table>

<table>
    <tr>
        <th colspan="2">表12.2 shared_ptr独有的操作</th>
    </tr>
    <tr>
        <td>make_shared<·T>(args)</td> <td>返回一个shared_ptr，指向一个动态分配的类型为T的对象</td>
    </tr>
    <tr>
        <td>shared_ptr<·T> p(q)</td> <td>p是shared_ptr q的拷贝。此操作会递增q中的引用计数</td>
    </tr>
    <tr>
        <td>p = q</td> <td>p和q都是shared_ptr，所保存的指针必须能相互转换。此操作会递减p的引用计数，递增q的引用计数；若p的引用计数为0，则其管理的内存释放</td>
    </tr>
    <tr>
        <td>p.unique()</td> <td>若p.use_count()为1，则返回true；否则返回false</td>
    </tr>
    <tr>
        <td>p.use_count()</td> <td>返回与p共享对象的智能指针的数量；主要用于调试</td>
    </tr>
</table>

**shared_ptr**的析构函数会递减它所指向的对象的引用计数，如果引用计数为0，shared_ptr的析构函数就会销毁对象，释放占用的内存。



### 12.1.2 直接管理内存
由内置指针(而不是智能指针)管理的动态内存在被显式释放前会一直存在.

指针在被delete后，就变成了悬空指针(dangling pointer).

不要混合使用普通指针和智能指针.

不要使用get初始化另一个智能指针或为智能指针赋值.

使用new和delete管理动态内存存在3个常见问题：
1. 忘记delete内存
2. 使用已经释放掉的对象
3. 同一块内存释放了2次

<table>
    <tr>
        <th colspan="2">表12.3 定义和改变shared_ptr的其他方法</th>
    </tr>
    <tr>
        <td>shared_ptr<·T> p(q)</td> <td>p管理内置指针q所指向的对象；q必须指向new分配的内存，且能够转换为T*类型</td>
    </tr>
    <tr>
        <td>shared_ptr<·T> p(u)</td> <td>p从unique_ptr u那里接管了对象的所有权；将u置为空</td>
    </tr>
    <tr>
        <td>shared_ptr<·T> p(q, d)</td> <td>p接管了内置指针q所指向的对象的所有权。q必须能转换为T*类型。p将使用可调用对象d来代替delete</td>
    </tr>
    <tr>
        <td>shared_ptr<·T> p(p2, d)</td> <td>p是shared_ptr p2的拷贝，p将用可调用对象d来代替delete</td>
    </tr>
    <tr>
        <td>p.reset()</td> <td>若p是唯一指向其对象的shared_ptr，reset会释放此对象。若传递了可选的参数内置指针q，会令p指向q，否则会将p置空。若传递了参数d，会调用d来释放q</td>
    </tr>
    <tr>
        <td>p.reset(q)</td> <td></td>
    </tr>
    <tr>
        <td>p.reset(q, d)</td> <td></td>
    </tr>
</table>

### 12.1.3 shared_ptr和new结合使用
### 12.1.4 智能指针和异常
智能指针陷阱：
- 不使用相同的内置指针值初始化(或reset)多个智能指针
- 不delete get()返回的指针
- 不使用get()初始化或reset另一个智能指针
- 如果使用get()返回的指针，记得在最后一个对应的智能指针销毁后，指针就变得无效了
- 如果使用智能指针管理的资源不是new分配的内存，记住传递给它一个删除器

### 12.1.5 unique_ptr类
**unique_ptr**: "独占"所指向的对象。

<table>
    <tr>
        <th colspan="2">表12.4 unique_ptr操作</th>
    </tr>
    <tr>
        <td>unique_ptr<·T> u1</td> <td>空unique_ptr，可以指向类型为T的对象。u1会使用delete来释放它的指针</td>
    </tr>
    <tr>
        <td>unique_ptr<·T, D> u2</td> <td>u2会使用一个类型为D的可调用对象来释放它的指针</td>
    </tr>
    <tr>
        <td>unique_ptr<·T, D> u(d)</td> <td>空unique_ptr，指向类型为T的对象，用类型为D的对象d代替delete</td>
    </tr>
    <tr>
        <td>u = nullptr</td> <td>释放u指向的对象，将u置空</td>
    </tr>
    <tr>
        <td>u.release()</td> <td>u放弃对指针的控制权，返回指针，并将u置空</td>
    </tr>
    <tr>
        <td>u.reset()</td> <td>释放u指向的对象</td>
    </tr>
    <tr>
        <td>u.reset(q)</td> <td>如果提供了内置指针q，令u指向这个对象；否则将u置空</td>
    </tr>
    <tr>
        <td>u.reset(nullptr)</td> <td></td>
    </tr>
</table>

### 12.1.6 weak_ptr类
**weak_ptr**: 指向shared_ptr所管理的对象，但不增加该对象的引用计数，不控制所指对象的生存期。
<table>
    <tr>
        <th colspan="2">表12.5 weak_ptr</th>
    </tr>
    <tr>
        <td>weak_ptr<·T> w</td> <td>空weak_ptr可以指向类型为T的对象</td>
    </tr>
    <tr>
        <td>weak_ptr<·T> w(sp)</td> <td>与shared_ptr sp指向相同对象的weak_ptr。T必须能转换为sp指向的类型</td>
    </tr>
    <tr>
        <td>w = p</td> <td>p可以是一个shared_ptr或一个weak_ptr。赋值后w与p共享对象</td>
    </tr>
    <tr>
        <td>w.reset()</td> <td>将w置空</td>
    </tr>
    <tr>
        <td>w.use_count()</td> <td>与w共享对象的shared_ptr的数量</td>
    </tr>
    <tr>
        <td>w.expired()</td> <td>若w.use_count()为0，返回true；否则返回false</td>
    </tr>
    <tr>
        <td>u.lock()</td> <td>如果expired为true，返回一个空shared_ptr；否则返回一个指向w的对象的shared_ptr</td>
    </tr>
</table>

## 12.2 动态数组
### 12.2.1 new和数组
动态分配一个空数组是合法的

### 12.2.2 allocator类
<table>
    <tr>
        <th colspan="3">表12.7 allocator类及其算法</th>
    </tr>
    <tr>
        <td>allocator<·T> a</td> <td>定义了一个名为a的allocator对象，它可以为类型T的对象分配内存</td> <td></td>
    </tr>
    <tr>
        <td>a.allocate(n)</td> <td>分配一段原始的、未构造的内存，保存n个类型为T的对象</td> <td></td>
    </tr>
    <tr>
        <td>a.deallocate(p, n)</td> <td>p是之前由allocate返回的指针，n是p创建时所要求的大小。在调用deallocate之前，须对每个在这个内存中的对象调用destroy</td> <td></td>
    </tr>
    <tr>
        <td>a.construct(p, args)</td> <td>p是之前由allocate返回的指针，args是构造对象时使用的参数。</td> <td>C++17标记为废弃，C++20移除</td>
    </tr>
    <tr>
        <td>a.destroy(p)</td> <td>对p指向的对象执行析构函数</td> <td>C++17标记为废弃，C++20移除</td>
    </tr>
</table>
<table>
    <tr>
        <th colspan="3">表12.8 allocator算法</th>
    </tr>
    <tr>
        <td>uninitialized_copy(beg, end, beg2)</td> <td>把迭代器beg到end之间元素拷贝到迭代器beg指定的原始内存中。beg2指向的内存须足够大</td> <td></td>
    </tr>
    <tr>
        <td>uninitialized_copy_n(beg, n, beg2)</td> <td>从迭代器beg开始拷贝n个元素到beg2指向的位置</td> <td></td>
    </tr>
    <tr>
        <td>uninitialized_fill(beg, end, t)</td> <td></td> <td></td>
    </tr>
    <tr>
        <td>uninitialized_fill(beg, n, t)</td> <td></td> <td></td>
    </tr>
</table>

## 12.3 使用标准库: 文本查询程序
### 12.3.1 文本查询程序设计
### 12.3.2 文本查询程序类的定义



## 第12章 练习题
### 12.1.1节练习
<b>练习12.1</b> 在此代码的结尾，b1和b2各包含多少个元素？
```c++
StrBlob b1;
{
    StrBlob b2 = {"a", "an", "the"};
    b1 = b2;
    b2.push_back("about");
}
```
<b>练习12.2</b> 编写你自己的StrBlob类，包含const版本的front和back。

<b>练习12.3</b> StrBlob需要const版本的push_back和pop_back吗？如果需要，添加进去。否则，解释为什么不需要。

<b>练习12.4</b> 在我们的check函数中，没有检查i是否大于0.为什么可以忽略这个检查？

<b>练习12.5</b> 我们未编写接受一个initializer_list explicit参数的构造函数。讨论这个设计策略的优点和缺点。

### 12.1.2节练习
<b>练习12.6</b> 编写函数，返回一个动态分配的int的vector。将此vector传递给另一个函数，这个函数读取标准输入，将读入的值保存在vector元素中。
再将vector传递给另一个函数，打印读入的值。记得在恰当的时刻delete vector。

<b>练习12.7</b> 重做上一题，这次使用shared_ptr而不是内置指针。

<b>练习12.8</b> 下面的函数是否有错误？如果有，解释错误原因。
```c++
bool b() {
    int * p = new int;
    // ...
    return p;
}
```
<b>练习12.9</b> 解释下面代码执行的结果。
```c++
int * q = new int(42), *r = new int(100);
r = q;
auto q2 = make_shared<int>(42), r2 = make_shared<int>(100);
r2 = q2;
```

### 12.1.3节练习
<b>练习12.10</b> 下面的代码调用了第413页中定义的process函数，解释此调用是否正确。如果不正确，应如何修改？
```c++
shared_ptr<int> p(new int(30));
process(shared_ptr<int>(p));
```
<b>练习12.11</b> 如果我们像下面这样调用process，会发生什么？
```c++
process(shared_ptr<int>(p.get()));
```
<b>练习12.12</b> p和q的定义如下，对于接下来的对process的每个调用，如果合法请解释它做了什么，如果不合法请说明原因。
```text
auto p = new int();
auto sp = make_shared<int>();
(a) process(sp);
(b) process(new int());
(c) process(p);
(d) process(shared_ptr<int>(p));
```
<b>练习12.13</b> 如果执行下面的代码，会发生什么？
```c++
auto sp = make_shared<int>();
auto p = sp.get();
delete p;
```

### 12.1.4节练习
<b>练习12.14</b> 编写你自己版本的用shared_ptr管理connection的函数。

<b>练习12.15</b> 重写上一题，用lambda代替end_connection函数。

### 12.1.5节练习
<b>练习12.16</b> 如果你试图拷贝或赋值unique_ptr，编译器并不总是能给出易于理解的错误信息。编写包含这种错误的程序，观察编译器如何诊断这种错误。

<b>练习12.17</b> 下面的unique_ptr声明中，哪些是合法的，哪些可能导致错误？
```text
int ix = 1024, *pi = &ix, *pi2 = new int(2048);
typedef unique_ptr<int> IntP;

(a) IntP p0(ix);             (b) IntP p1(pi);
(c) IntP p2(pi2);            (d) IntP p3(&ix);
(e) IntP p4(new int(2048));  (f)IntP p5(p2.get());
```
<b>练习12.18</b> shared_ptr为什么没有release函数？

### 12.1.6节练习
<b>练习12.19</b> 定义你自己版本的StrBlobPtr，更新StrBlob类，加入恰当的friend声明和begin、end成员。

<b>练习12.20</b> 编写程序，逐行读入一个输入文件，将内容存入一个StrBlob中，用一个StrBlobPtr打印出StrBlob中的每个元素。

<b>练习12.21</b> 也可以这样编写StrBlobPtr的deref成员:
```c++
std::string& deref() const {
    return (*check(curr, "dereference past end"))[curr];
}
```
你认为哪个版本更好？为什么？

<b>练习12.22</b> 为了能让StrBlobPtr使用const StrBlob，你觉得应该如何修改？定义一个名为ConstStrBlobPtr的类，使其能够指向const StrBlob。

### 12.2.1节练习
<b>练习12.23</b> 编写一个程序，连接2个字符串字面常量，将结果保存在一个动态分配的char数组中。重写这个程序，连接2个标准库string对象。

<b>练习12.24</b> 编写要给程序，从标准输入读取一个字符串，存入一个动态分配的字符数组中。描述你的程序如何处理变长输入。测试你的程序，输入一个超出你分配的数组长度的字符串。

<b>练习12.25</b> 给定下面的new表达式，你应该如何释放pa?
```c++
int * pa = new int[10];

// 
delete [] pa;
```

### 12.2.2节练习
<b>练习12.26</b> 用allocator重写第427页中的程序。

### 12.3.1节练习
<b>练习12.27</b> TextQuery和QueryResult类只使用了我们已经介绍过的语音和标准库特性。不要提前看后续章节内容，只用已经学到的知识对这2个类编写自己的版本。

<b>练习12.28</b> 编写程序实现文本查询，不要定义类来管理数据。你的程序应该接受一个文件，并与用户交互来查询单词。使用vector、map和set容器来保存来自文件的数据并生成查询的结果。

<b>练习12.29</b> 我们曾经用do while循环来编写管理用户交互的循环。用do while重写本节程序，解释你倾向于哪个版本，为什么？

### 12.3.2节练习
<b>练习12.30</b> 定义你自己版本的TextQuery和QueryResult类，并执行12.3.1节中的run_queries函数。

<b>练习12.31</b> 如果用vector代替set保存行号，会有什么区别？哪种方法更好？为什么？

<b>练习12.32</b> 重写TextQuery和QueryResult类，用StrBlob代替vector<string>保存输入文件。

<b>练习12.33</b> 在第15章中我们将扩展查询系统，在QueryResult类中将会需要一些额外的成员。添加名为begin和end的成员，返回一个迭代器，指向一个给定
查询返回的行号的set中的位置。再添加一个名为get_file的成员，返回一个shared_ptr，指向QueryResult对象中的文件。
