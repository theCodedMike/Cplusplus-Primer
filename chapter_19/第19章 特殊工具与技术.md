# 第19章 特殊工具与技术
## 19.1 控制内存分配
### 19.1.1 重载new和delete
定义operator new函数和operator delete函数，既可以在全局作用域种，也可以定义为成员函数。


标准库定义了8个重载版本的new和delete函数:
```c++
// 可能抛出异常
void *operator new(size_t); // 分配一个对象 在构造函数之前执行
void *operator new[](size_t); // 分配一个数组
void *operator delete(void*) noexcept; // 释放一个对象  在析构函数之后执行
void *operator delete[](void*) noexcept; // 释放一个数组
// 承诺不会抛出异常
void *operator new(size_t, nothrow_t&) noexcept;
void *operator new[](size_t, nothrow_t&); noexcept;
void *operator delete(void*, nothrow_t&) noexcept;
void *operator delete[](void*, nothrow_t&) noexcept;
```
### 19.1.2 定位new表达式
调用析构函数会销毁对象，但是不会释放内存。

## 19.2 运行时类型识别
**运行时类型识别**(runtime type identification, RTTI)的功能由2个运算符实现:
- typeid运算符，用于返回表达式的类型
- dynamic_cast运算符，用于将基类的指针或引用安全地转换成派生类的指针或引用

### 19.2.1 dynamic_cast运算符
**dynamic_cast**运算符的使用形式如下所示:
```text
dynamic_cast<type*>(e)  // e是一个有效的指针
dynamic_cast<type&>(e)  // e必须是一个左值
dynamic_cast<type&&>(e) // e不能是左值
```
其中type必须是一个类类型，并且该类型一般含有虚函数。e的类型必须符合以下3个条件之一：
- e的类型是目标type的公有派生类
- e的类型是目标type的公有基类
- e的类型就是目标type的类型




### 19.2.2 typeid运算符
### 19.2.3 使用RTTI
### 19.2.4 type_info类

## 19.3 枚举类型

## 19.4 类成员指针
### 19.4.1 数据成员指针
### 19.4.2 成员函数指针
### 19.4.3 将成员函数用作可调用对象

## 19.5 嵌套类
## 19.6 union: 一种节省空间的类
## 19.7 局部类
## 19.8 固有的不可移植的特性
### 19.8.1 位域
### 19.8.2 volatile限定符
### 19.8.3 链接指示: extern "C"


## 第19章 练习题
### 19.1.1节练习
<b>练习19.1</b> 使用malloc编写你自己的operator new(size_t)函数，使用free编写operator delete(void *)函数。

<b>练习19.2</b> 默认情况下，allocator类使用operator new获取存储空间，然后使用operator delete释放它。利用上一题中的2个函数重新编译
并运行你的StrVec程序(参见13.5节，第465页)


### 19.2.1节练习
<b>练习19.3</b> 已知存在如下的类继承体系，其中每个类分别定义了一个公有的默认的构造函数和一个虚析构函数：
```c++
class A {};
class B : public A {};
class C : public B {};
class D : public B, public A {};
```
下面的哪个dynamic_case将失败？
```text
(a) A *pa = new C;
    B *pb = dynamic_cast<B *>(pa);
(b) B *pb = new B;
    C *pc = dynamic_cast<C *>(pb);
(c) A *pa = new D;
    B *pb = dynamic_cast<B *>(pa);
```
<b>练习19.4</b> 使用上一个练习定义的类改写下面的代码，将表达式*pa转换成类型C&：
```c++
if (C *pc = dynamic_cast<C *>(pa)) {
    // 使用C的成员
} else {
    // 使用A的成员
}
```
<b>练习19.5</b> 在什么情况下你应该使用dynamic_cast替代虚函数？


### 19.2.2节练习
<b>练习19.6</b> 编写一条表达式将Query_base指针动态转换为AndQuery指针(参见15.9.1节，第564页)，分别使用AndQuery的对象以及其他类型的对象测试
转换是否有效。打印一条表示类型转换是否成功的信息，确保实际输出的结果与期望的一致。

<b>练习19.7</b> 编写与上一个练习类似的转换，这一次将Query_base对象转换为AndQuery的引用。重复上面的测试过程，确保转换能正常工作。

<b>练习19.8</b> 编写一条typeid表达式检查2个Query_base对象是否指向同一种类型。再检查该类型是否是AndQuery。


### 19.2.3节练习
<b>练习19.9</b> 编写与本节最后一个程序类似的代码，令其打印你的编译器为一些常见类型所起的名字。如果你得到的输出结果与本书类似，尝试编写一个函数将
这些字符串翻译成人们更容易读懂的形式。

<b>练习19.10</b> 已知存在如下的类继承体系，其中每个类定义了一个默认公有的构造函数和一个虚析构函数。下面的语句将打印哪些类型名字？
```text
class A {};
class B : public A {};
class C : public B {};

(a) A *pa = new C;
    cout << typeid(pa).name() << endl;
(b) C cobj;
    A &ra = cobj;
    cout << typeid(&ra).name() << endl;
(c) B *px = new B;
    A &ra = *px;
    cout << typeid(ra).name() << endl;
```








