# 第19章 特殊工具与技术
## 19.1 控制内存分配
### 19.1.1 重载new和delete
定义operator new函数和operator delete函数，既可以在全局作用域种，也可以定义为成员函数。


标准库定义了8个重载版本的new和delete函数:
```c++
// 可能抛出异常
void *operator new(size_t); // 分配一个对象 在构造函数之前执行
void *operator new[](size_t); // 分配一个数组
void *operator delete(void*) noexcept; // 释放一个对象  在析构函数之后执行
void *operator delete[](void*) noexcept; // 释放一个数组
// 承诺不会抛出异常
void *operator new(size_t, nothrow_t&) noexcept;
void *operator new[](size_t, nothrow_t&); noexcept;
void *operator delete(void*, nothrow_t&) noexcept;
void *operator delete[](void*, nothrow_t&) noexcept;
```
### 19.1.2 定位new表达式
调用析构函数会销毁对象，但是不会释放内存。

## 19.2 运行时类型识别
**运行时类型识别**(runtime type identification, RTTI)的功能由2个运算符实现:
- typeid运算符，用于返回表达式的类型
- dynamic_cast运算符，用于将基类的指针或引用安全地转换成派生类的指针或引用

### 19.2.1 dynamic_cast运算符
**dynamic_cast**运算符的使用形式如下所示:
```text
dynamic_cast<type*>(e)  // e是一个有效的指针
dynamic_cast<type&>(e)  // e必须是一个左值
dynamic_cast<type&&>(e) // e不能是左值
```
其中type必须是一个类类型，并且该类型一般含有虚函数。e的类型必须符合以下3个条件之一：
- e的类型是目标type的公有派生类
- e的类型是目标type的公有基类
- e的类型就是目标type的类型
### 19.2.2 typeid运算符
### 19.2.3 使用RTTI
### 19.2.4 type_info类

## 19.3 枚举类型

## 19.4 类成员指针
### 19.4.1 数据成员指针
### 19.4.2 成员函数指针
### 19.4.3 将成员函数用作可调用对象

## 19.5 嵌套类
嵌套类的名字在外层类作用域中是可见的，在外层类作用域之外是不可见的。 嵌套类和外层类是相互独立的。

## 19.6 union: 一种节省空间的类
**联合**(union)可以有多个数据成员，但在任意时刻只有一个数据成员可以有值。

**匿名union**不能包含受保护的成员或私有成员，也不能定义成员函数。在匿名union的定义所在作用域内，其成员可以直接访问。

## 19.7 局部类
**局部类(local class)**: 定义在某个函数的内部的类。局部类的所有成员必须完整定义在类的内部。

局部类只能访问外层作用域定义的类型名、静态变量以及枚举成员。

## 19.8 固有的不可移植的特性
### 19.8.1 位域
**位域**(bit field)在内存中的布局是与机器相关的。

### 19.8.2 volatile限定符
### 19.8.3 链接指示: extern "C"













## 第19章 练习题
### 19.1.1节练习
<b>练习19.1</b> 使用malloc编写你自己的operator new(size_t)函数，使用free编写operator delete(void *)函数。

<b>练习19.2</b> 默认情况下，allocator类使用operator new获取存储空间，然后使用operator delete释放它。利用上一题中的2个函数重新编译
并运行你的StrVec程序(参见13.5节，第465页)


### 19.2.1节练习
<b>练习19.3</b> 已知存在如下的类继承体系，其中每个类分别定义了一个公有的默认的构造函数和一个虚析构函数：
```c++
class A {};
class B : public A {};
class C : public B {};
class D : public B, public A {};
```
下面的哪个dynamic_case将失败？
```text
(a) A *pa = new C;
    B *pb = dynamic_cast<B *>(pa);
(b) B *pb = new B;
    C *pc = dynamic_cast<C *>(pb);
(c) A *pa = new D;
    B *pb = dynamic_cast<B *>(pa);
```
<b>练习19.4</b> 使用上一个练习定义的类改写下面的代码，将表达式*pa转换成类型C&：
```c++
if (C *pc = dynamic_cast<C *>(pa)) {
    // 使用C的成员
} else {
    // 使用A的成员
}
```
<b>练习19.5</b> 在什么情况下你应该使用dynamic_cast替代虚函数？


### 19.2.2节练习
<b>练习19.6</b> 编写一条表达式将Query_base指针动态转换为AndQuery指针(参见15.9.1节，第564页)，分别使用AndQuery的对象以及其他类型的对象测试
转换是否有效。打印一条表示类型转换是否成功的信息，确保实际输出的结果与期望的一致。

<b>练习19.7</b> 编写与上一个练习类似的转换，这一次将Query_base对象转换为AndQuery的引用。重复上面的测试过程，确保转换能正常工作。

<b>练习19.8</b> 编写一条typeid表达式检查2个Query_base对象是否指向同一种类型。再检查该类型是否是AndQuery。


### 19.2.3节练习
<b>练习19.9</b> 编写与本节最后一个程序类似的代码，令其打印你的编译器为一些常见类型所起的名字。如果你得到的输出结果与本书类似，尝试编写一个函数将
这些字符串翻译成人们更容易读懂的形式。

<b>练习19.10</b> 已知存在如下的类继承体系，其中每个类定义了一个默认公有的构造函数和一个虚析构函数。下面的语句将打印哪些类型名字？
```text
class A {};
class B : public A {};
class C : public B {};

(a) A *pa = new C;
    cout << typeid(pa).name() << endl;
(b) C cobj;
    A &ra = cobj;
    cout << typeid(&ra).name() << endl;
(c) B *px = new B;
    A &ra = *px;
    cout << typeid(ra).name() << endl;
```


### 19.4.1节练习
<b>练习19.11</b> 普通的数据指针和指向数据成员的指针有何区别？

<b>练习19.12</b> 定义一个成员指针，令其可以指向Screen类的cursor成员。通过该指针获得Screen::cursor的值。

<b>练习19.13</b> 定义一个类型，使其可以表示指向Sales_data类的bookNo成员的指针。


### 19.4.2节练习
<b>练习19.14</b> 下面的代码合法嘛？如果合法，代码的含义是什么？如果不合法，解释原因。
```c++
auto pmf = &Screen::get_cursor;
pmf = &Screen::get;
```
<b>练习19.15</b> 普通函数指针和指向成员函数的指针有何区别？

<b>练习19.16</b> 声明一个类型别名，令其作为指向Sales_data的avg_price成员的指针的同义词。

<b>练习19.17</b> 为Screen的所有成员函数类型各定义一个类型别名。


### 19.4.3节练习
<b>练习19.18</b> 编写一个函数，使用count_if统计在给定的vector中有多少个空string。

<b>练习19.19</b> 编写一个函数，令其接受vector<Sales_data>并查找平均价格高于某个值的第一个元素。


### 19.5节练习
<b>练习19.20</b> 将你的QueryResult类嵌套在TextQuery中，然后重新运行12.3.2节(第435页)中使用了TextQuery的程序。


### 19.6节练习
<b>练习19.21</b> 编写你自己的Token类。

<b>练习19.22</b> 为你的Token类添加一个Sales_data类型的成员。

<b>练习19.23</b> 为你的Token类添加移动构造函数和移动赋值运算符。

<b>练习19.24</b> 如果我们将一个Token对象赋给它自己将发生什么情况？

<b>练习19.25</b> 编写一系列赋值运算符，令其分别接受union中各种类型的值。


### 19.8.3节练习
<b>练习19.26</b> 说明下列声明语句的含义并判断它们是否合法：
```c++
extern "C" int compute(int *, int);
extern "C" double compute(double *, double);
```
