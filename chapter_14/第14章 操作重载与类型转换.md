# 第14章 操作重载与类型转换
## 14.1 基本概念
我们只能重载已有的运算符，不能定义新的运算符。
<table>
    <tr>
        <th colspan="6">表14.1 运算符</th>
    </tr>
    <tr>
        <th colspan="6" style="background-color: cadetblue; text-align: left">可以被重载的运算符</th>
    </tr>
    <tr>
        <td>+</td> <td>-</td> <td>*</td> <td>/</td> <td>%</td> <td>^</td>
    </tr>
    <tr>
        <td>&</td> <td>|</td> <td>~</td> <td>!</td> <td>,</td> <td>=</td>
    </tr>
    <tr>
        <td><</td> <td>></td> <td><=</td> <td>>=</td> <td>++</td> <td>--</td>
    </tr>
    <tr>
        <td><<</td> <td>>></td> <td>==</td> <td>!=</td> <td>&&</td> <td>||</td>
    </tr>
    <tr>
        <td>+=</td> <td>-=</td> <td>/=</td> <td>%=</td> <td>^=</td> <td>&=</td>
    </tr>
    <tr>
        <td>|=</td> <td>*=</td> <td><<=</td> <td>>>=</td> <td>[]</td> <td>()</td>
    </tr>
    <tr>
        <td>-></td> <td>->*</td> <td>new</td> <td>new[]</td> <td>delete</td> <td>delete[]</td>
    </tr>
    <tr>
        <th colspan="6" style="background-color: cadetblue; text-align: left">不能被重载的运算符</th>
    </tr>
    <tr>
        <td></td> <td>::</td> <td>.*</td> <td>.</td> <td>?:</td> <td></td>
    </tr>
</table>

```text
data1 + data2; // 二者是等价的
operator+(data1, data2);

data1 += data2; // 二者是等价的
data1.operator+=(data2);
```

逻辑&&和||运算符的重载版本无法保留内置运算符的短路求值属性，2个运算对象总是会被求值。
我们一般不重载`逻辑&&`、`逻辑||`、`逗号`、`取地址`运算符。

## 14.2 输入和输出运算符
输入输出运算符必须是非成员函数，且一般是友元函数。
### 14.2.1 重载输出运算符
### 14.2.2 重载输入运算符

## 14.3 算术和关系运算符
### 14.3.1 相等运算符
### 14.3.2 关系运算符

## 14.4 赋值运算符
赋值运算符、复合赋值运算符应该被定义成类的成员，且应返回左侧运算对象的引用。

## 14.5 下标运算符
如果一个类包含下标运算符，则它通常会定义2个版本：一个返回普通引用，另一个返回常量引用。

## 14.6 递增和递减运算符
定义递增和递减运算符的类应该同时定义前置版本和后置版本，且通常被定义为类的成员函数。

## 14.7 成员访问运算符
箭头运算、解引用运算应该时类的成员函数。

重载的箭头运算符必须返回类的指针或者自定义了箭头运算符的某个类的对象。

## 14.8 函数调用运算符
函数调用运算符必须是成员函数，可以有多个重载版本。

### 14.8.1 lambda是函数对象
通过值捕获的变量会被拷贝到lambda中；通过引用捕获的变量由程序负责引用的对象确实存在，不会在lambda中存储；由lambda产生的类必须为每个值捕获的变量建立
对应的数据成员，同时创建构造函数。

lambda表达式产生的类不含默认构造函数、赋值运算符、析构函数。

### 14.8.2 标准库定义的函数对象
<table>
    <tr>
        <th colspan="3">表14.2 标准库函数对象</th>
    </tr>
    <tr>
        <td><b>算术</b></td> <td><b>关系</b></td> <td><b>逻辑</b></td>
    </tr>
    <tr>
        <td>plus< Type></td> <td>equal_to< Type></td> <td>logical_and< Type></td>
    </tr>
    <tr>
        <td>minus< Type></td> <td>not_equal_to< Type></td> <td>logical_or< Type></td>
    </tr>
    <tr>
        <td>multiplies< Type></td> <td>greater< Type></td> <td>logical_not< Type></td>
    </tr>
    <tr>
        <td>divides< Type></td> <td>greater_equal< Type></td> <td></td>
    </tr>
    <tr>
        <td>modulus< Type></td> <td>less< Type></td> <td></td>
    </tr>
    <tr>
        <td>negate< Type></td> <td>less_equal< Type></td> <td></td>
    </tr>
</table>

### 14.8.3 可调用对象与function
C++语言中可调用的对象有：函数、函数指针、lambda表达式、bind创建的对象以及重载了函数调用运算符的类。

<table>
    <tr>
        <th colspan="2">表14.3 function的操作</th>
    </tr>
    <tr>
        <td>function< T> f;</td> <td>f是一个用来存储可调用对象的空function，这些可调用对象的调用形式应该与函数类型T相同</td>
    </tr>
    <tr>
        <td>function< T> f(nullptr);</td> <td>显式地构造一个空function</td>
    </tr>
    <tr>
        <td>function< T> f(obj);</td> <td>在f中存储可调用对象obj的副本</td>
    </tr>
    <tr>
        <td>f</td> <td>当f含有一个可调用对象时为真；否则为假</td>
    </tr>
    <tr>
        <td>f(args)</td> <td>调用f中的对象，args是参数</td>
    </tr>
    <tr>
        <th colspan="2" style="text-align: left">定义为function< T>的成员的类型</th>
    </tr>
    <tr>
        <td>result_type</td> <td>该function类型的可调用对象返回的类型</td>
    </tr>
    <tr>
        <td>argument_type</td> <td>当T有一个或二个实参时定义的类型</td>
    </tr>
    <tr>
        <td>first_argument_type</td> <td></td>
    </tr>
    <tr>
        <td>second_argument_type</td> <td></td>
    </tr>
</table>

## 14.9 重载、类型转换运算符
### 14.9.1 类型转换运算符
**类型转换运算符**是类的一种特殊成员函数，负责将一个类类型的值转换成其他类型，其形式一般为：
`operator type() const;`

向bool的类型转换通常用在条件部分，所以operator bool一般定义成explicit的。
### 14.9.2 避免有二义性的类型转换
通常情况下，不要为类定义相同的类型转换，也不要在类中定义2个及2个以上转换源或转换目标是算术类型的转换。

### 14.9.3 函数匹配与重载运算符





## 第14章 练习题
### 14.1.1节练习
<b>练习14.1</b> 在什么情况下重载的运算符与内置运算符有所区别？在什么情况下重载的运算符与内置运算符没有区别？

<b>练习14.2</b> 为Sales_data编写重载的输入、输出、加法和复合赋值运算符。

<b>练习14.3</b> string和vector都定义了重载的==以比较各自的对象，假设svec1和svec2是存放string的vector，确定在下面的表达式中分别使用了哪个版本的==？
```text
(a) "cobble" == "stone"      (b) svec1[0] == svec2[0]
(c) svec1 == svec2           (d) svec1[0] == "stone"
```
<b>练习14.4</b> 如何确定下列运算符是否应该是类的成员？
```text
(a) %    (b) %=    (c) ++    (d) ->     (e) <<    (f) &&     (g) ==     (h) ()
```
<b>练习14.5</b> 在7.5.1节的练习7.40中，编写了下列类中某一个的框架，请问在这个类中应该定义重载的运算符吗？如果是，写出来。
```text
(a) Book           (b) Date              (c) Employee
(d) Vehicle        (e) Object            (f) Tree
```

### 14.2.1节练习
<b>练习14.6</b> 为你的sales_data类定义输出运算符。

<b>练习14.7</b> 你在13.5节的练习中曾经编写了一个String类，为它定义一个输出运算符。

<b>练习14.8</b> 你在7.5.1节的练习7.40中曾经选择并编写了一个类，为它定义一个输出运算符。

### 14.2.2节练习
<b>练习14.9</b> 为你的Sales_data类定义输入运算符。

<b>练习14.10</b> 对于Sales_data的输入运算符来说如果给定了下面的输入将发生什么情况？
```text
(a) 0-201-99999-9 10 24.95             (b) 10 24.95 0-201-99999-9
```
<b>练习14.11</b> 下面的Sales_data输入运算符存在错误吗？如果有，指出来。对于这个输入运算符如果仍然给定上个练习的输入将发生什么情况？
```c++
istream & operator>>(istream &in, Sales_data& s) {
    double price;
    in >> s.bookNo >> s.units_sold >> price;
    s.revenue = s.units_sold * price;
    return in;
}
```
<b>练习14.12</b> 你在7.5.1节的练习7.40中曾经选择并编写了一个类，为它定义一个输入运算符并确保该运算符可以处理输入错误。

### 14.3节练习
<b>练习14.13</b> 你认为Sales_data类还应该支持哪些其他算术运算符？如果有的话，请给出它们的定义。

<b>练习14.14</b> 你觉得为什么调用operator+=来定义operator+比其他方法更有效？

<b>练习14.15</b> 你在7.5.1节的练习7.40中曾经选择并编写了一个类，你认为它应该含有其他算术运算符吗？如果是，实现它们；如果不是，请解释原因。

### 14.3.1节练习
<b>练习14.16</b> 为你的StrBlob类、StrBlobPtr类、StrVec类和String类分别定义相等和不等运算符。

<b>练习14.17</b> 你在7.5.1节的练习7.40中曾经选择并编写了一个类，你认为它应该含有相等运算符吗？如果是，实现它们；如果不是，请解释原因。

### 14.3.2节练习
<b>练习14.18</b> 为你的StrBlob类、StrBlobPtr类、StrVec类和String类定义关系运算符。

<b>练习14.19</b> 你在7.5.1节的练习7.40中曾经选择并编写了一个类，你认为它应该含有关系运算符吗？如果是，实现它们；如果不是，请解释原因。

### 14.4节练习
<b>练习14.20</b> 为你的Sales_data类定义加法和复合赋值运算符。

<b>练习14.21</b> 编写Sales_data类的+和+=运算符，使得+执行实际的加法操作而+=调用+。相比于14.3节和14.4节对这2个运算符的定义，本题的定义有何缺点？

<b>练习14.22</b> 定义赋值运算符的一个新版本，使得我们能把一个表示ISBN的string赋给一个Sales_data对象。

<b>练习14.23</b> 为你的StrVec类定义一个initializer_list赋值运算符。

<b>练习14.24</b> 你在7.5.1节的练习7.40中曾经选择并编写了一个类，你认为它应该含有拷贝赋值和移动赋值运算符吗？如果是，实现它们。

<b>练习14.25</b> 上题的这个类还需要定义其他赋值运算符吗？如果是，请实现它们；同时说明运算对象应该是什么类型并解释原因。

### 14.5节练习
<b>练习14.26</b> 为你的StrBlob类、StrBlobPtr类、StrVec类和String类定义下标运算符。

### 14.6节练习
<b>练习14.27</b> 为你的StrBlobPtr类添加递增和递减运算符。

<b>练习14.28</b> 为你的StrBlobPtr类添加加法和减法运算符，使其可以实现指针的算术运算。

<b>练习14.29</b> 为什么不定义const版本的递增和递减运算符？

### 14.7节练习
<b>练习14.30</b> 为你的StrBlobPtr类和在12.1.6节练习12.22中定义的ConstStrBlobPtr类分别添加解引用运算符和箭头运算符。注意：因为ConstStrBlobPtr
的数据成员指向const vector，所以ConstStrBlobPtr中的运算符必须返回常量引用。

<b>练习14.31</b> 我们的StrBlobPtr类没有定义拷贝构造函数、赋值运算符及析构函数，为什么？

<b>练习14.32</b> 定义一个类令其含有指向StrBlobPtr对象的指针，为这个类定义重载的箭头运算符。

### 14.8节练习
<b>练习14.33</b> 一个重载的函数调用运算符应该接受几个运算对象？

<b>练习14.34</b> 定义一个函数对象类，令其执行if-then-else的操作：该类的调用运算符接受3个形参，它首先检查第1个形参，如果成功返回第2个形参；
如果不成功返回第3个形参的值。

<b>练习14.35</b> 编写一个类似于PrintString的类，令其从istream中读取一行输入，然后返回一个表示我们所读内容的string。如果读取失败，返回空string。

<b>练习14.36</b> 使用前一个练习定义的类读取标准输入，将每一行保存为vector的一个元素。

<b>练习14.37</b> 编写一个类令其检查2个值是否相等。使用该对象及标准库算法编写程序，令其替换某个序列中具有给定值的所有实例。

### 14.8.1节练习
<b>练习14.38</b> 编写一个类令其检查某个给定的string对象的长度是否与一个阈值相等。使用该对象编写程序，统计并报告在输入的文件中长度为1的单词有多少
个，长度为2的单词有多少个，...，长度为10的单词有多少个。

<b>练习14.39</b> 修改上一题的程序令其报告长度在1-9之间的单词有多少个，长度在10以上的单词有多少个。

<b>练习14.40</b> 重新编写10.3.2节的biggies函数，使用函数对象类替换其中的lambda表达式。

<b>练习14.41</b> 你认为C++11新标准为什么要增加lambda？对你而言，什么情况下会使用lambda，什么情况下使用类？

### 14.8.2节练习
<b>练习14.42</b> 使用标准库函数对象及适配器定义一条表达式，令其

(a) 统计大于1024的值有多少个。

(b) 找到第一个不等于pooh的字符串。

(c) 将所有的值乘以2.

<b>练习14.43</b> 使用标准库函数对象判断一个给定的int值是否能被int容器中的所有元素整除。

### 14.8.3节练习
<b>练习14.44</b> 编写一个简单的桌面计算器使其能处理二元运算。

### 14.9.1节练习
<b>练习14.45</b> 编写类型转换运算符将一个Sales_data对象分别转换成string和double，你认为这些运算符的返回值应该是什么？

<b>练习14.46</b> 你认为应该为Sales_data类定义上面2种类型转换运算符吗？应该把它们声明成explicit的吗？为什么？

<b>练习14.47</b> 说明下面这2个类型转换运算符的区别：
```c++
struct Integral {
    operator const int();
    operator int() const;
}
```
<b>练习14.48</b> 你在7.5.1节的练习7.40中曾经选择并编写了一个类，你认为它应该含有向bool的类型转换运算符吗？如果是，解释原因并说明该运算符是否应该是explicit的；
如果不是，请解释原因。

<b>练习14.49</b> 为上一题提到的类定义一个转换目标是bool的类型转换运算符，先不用在意这么做是否应该。

### 14.9.2节练习
<b>练习14.50</b> 在初始化ex1和ex2的过程种，可能用到哪些类类型的转换序列呢？说明初始化是否正确并解释原因。
```c++
struct LongDouble {
    LongDouble(double = 0.0);
    operator double();
    operator float();
};

LongDouble ldObj;
int ex1 = ldObj;
float ex2 = ldObj;
```
<b>练习14.51</b> 在调用calc的过程中，可能用到哪些类型转换序列呢？说明最佳可行函数是如何被选出来的。
```c++
void calc(int);
void calc(LongDouble);
double dval;
calc(dval);     // 哪个calc?
```

### 14.9.3节练习
<b>练习14.52</b> 在下面的加法表达式种分别选用了哪个operator+？列出候选函数、可行函数及为每个可行函数的实参执行的类型转换：
```c++
struct LongDouble {
    LongDouble operator+(const SmallInt&);
};
LongDouble operator+(LongDouble&, double);
SmallInt si;
LongDouble ld;
ld = si + ld;
ld = ld + si;
```
<b>练习14.53</b> 假设我们已经定义了如第522页所示的SmallInt，判断下面的加法表达式是否合法。如何合法，使用了哪个加法运算符？如何不合法，应该怎么修改代码使其合法？
```c++
SmallInt s1;
double d = s1 + 3.14;
```

