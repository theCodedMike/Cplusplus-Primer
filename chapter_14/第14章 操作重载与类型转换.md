# 第14章 操作重载与类型转换
## 14.1 基本概念
我们只能重载已有的运算符，不能定义新的运算符。
<table>
    <tr>
        <th colspan="6">表14.1 运算符</th>
    </tr>
    <tr>
        <th colspan="6" style="background-color: cadetblue; text-align: left">可以被重载的运算符</th>
    </tr>
    <tr>
        <td>+</td> <td>-</td> <td>*</td> <td>/</td> <td>%</td> <td>^</td>
    </tr>
    <tr>
        <td>&</td> <td>|</td> <td>~</td> <td>!</td> <td>,</td> <td>=</td>
    </tr>
    <tr>
        <td><</td> <td>></td> <td><=</td> <td>>=</td> <td>++</td> <td>--</td>
    </tr>
    <tr>
        <td><<</td> <td>>></td> <td>==</td> <td>!=</td> <td>&&</td> <td>||</td>
    </tr>
    <tr>
        <td>+=</td> <td>-=</td> <td>/=</td> <td>%=</td> <td>^=</td> <td>&=</td>
    </tr>
    <tr>
        <td>|=</td> <td>*=</td> <td><<=</td> <td>>>=</td> <td>[]</td> <td>()</td>
    </tr>
    <tr>
        <td>-></td> <td>->*</td> <td>new</td> <td>new[]</td> <td>delete</td> <td>delete[]</td>
    </tr>
    <tr>
        <th colspan="6" style="background-color: cadetblue; text-align: left">不能被重载的运算符</th>
    </tr>
    <tr>
        <td></td> <td>::</td> <td>.*</td> <td>.</td> <td>?:</td> <td></td>
    </tr>
</table>

```text
data1 + data2; // 二者是等价的
operator+(data1, data2);

data1 += data2; // 二者是等价的
data1.operator+=(data2);
```

逻辑&&和||运算符的重载版本无法保留内置运算符的短路求值属性，2个运算对象总是会被求值。
我们一般不重载`逻辑&&`、`逻辑||`、`逗号`、`取地址`运算符。

## 14.2 输入和输出运算符
输入输出运算符必须是非成员函数

### 14.2.1 重载输出运算符
### 14.2.2 重载输入运算符

## 14.3 算术和关系运算符
### 14.3.1 相等运算符
### 14.3.2 关系运算符

## 14.4 赋值运算符

## 14.5 下标运算符

## 14.6 递增和递减运算符

## 14.7 成员访问运算符

## 14.8 函数调用运算符
### 14.8.1 lambda是函数对象
### 14.8.2 标准库定义的函数对象
### 14.8.3 可调用对象与function

## 14.9 重载、类型转换运算符
### 14.9.1 类型转换运算符
### 14.9.2 避免有二义性的类型转换
### 14.9.3 函数匹配与重载运算符





## 第14章 练习题
### 14.1.1节练习
<b>练习14.1</b> 在什么情况下重载的运算符与内置运算符有所区别？在什么情况下重载的运算符与内置运算符没有区别？

<b>练习14.2</b> 为Sales_data编写重载的输入、输出、加法和复合赋值运算符。

<b>练习14.3</b> string和vector都定义了重载的==以比较各自的对象，假设svec1和svec2是存放string的vector，确定在下面的表达式中分别使用了哪个版本的==？
```text
(a) "cobble" == "stone"      (b) svec1[0] == svec2[0]
(c) svec1 == svec2           (d) svec1[0] == "stone"
```
<b>练习14.4</b> 如何确定下列运算符是否应该是类的成员？
```text
(a) %    (b) %=    (c) ++    (d) ->     (e) <<    (f) &&     (g) ==     (h) ()
```
<b>练习14.5</b> 在7.5.1节的练习7.40中，编写了下列类中某一个的框架，请问在这个类中应该定义重载的运算符吗？如果是，写出来。
```text
(a) Book           (b) Date              (c) Employee
(d) Vehicle        (e) Object            (f) Tree
```

### 14.2.1节练习
<b>练习14.6</b> 为你的sales_data类定义输出运算符。

<b>练习14.7</b> 你在13.5节的练习中曾经编写了一个String类，为它定义一个输出运算符。

<b>练习14.8</b> 你在7.5.1节的练习7.40中曾经选择并编写了一个类，为它定义一个输出运算符。

### 14.2.2节练习
<b>练习14.9</b> 为你的Sales_data类定义输入运算符。

<b>练习14.10</b> 对于Sales_data的输入运算符来说如果给定了下面的输入将发生什么情况？
```text
(a) 0-201-99999-9 10 24.95             (b) 10 24.95 0-201-99999-9
```
<b>练习14.11</b> 下面的Sales_data输入运算符存在错误吗？如果有，指出来。对于这个输入运算符如果仍然给定上个练习的输入将发生什么情况？
```c++
istream & operator>>(istream &in, Sales_data& s) {
    double price;
    in >> s.bookNo >> s.units_sold >> price;
    s.revenue = s.units_sold * price;
    return in;
}
```
<b>练习14.12</b> 你在7.5.1节的练习7.40中曾经选择并编写了一个类，为它定义一个输入运算符并确保该运算符可以处理输入错误。

### 14.3节练习
<b>练习14.13</b> 你认为Sales_data类还应该支持哪些其他算术运算符？如果有的话，请给出它们的定义。

<b>练习14.14</b> 你觉得为什么调用operator+=来定义operator+比其他方法更有效？

<b>练习14.15</b> 你在7.5.1节的练习7.40中曾经选择并编写了一个类，你认为它应该含有其他算术运算符吗？如果是，实现它们；如果不是，请解释原因。

### 14.3.1节练习
<b>练习14.16</b> 为你的StrBlob类、StrBlobPtr类、StrVec类和String类分别定义相等和不等运算符。

<b>练习14.17</b> 你在7.5.1节的练习7.40中曾经选择并编写了一个类，你认为它应该含有相等运算符吗？如果是，实现它们；如果不是，请解释原因。

### 14.3.2节练习
<b>练习14.18</b> 为你的StrBlob类、StrBlobPtr类、StrVec类和String类定义关系运算符。

<b>练习14.19</b> 你在7.5.1节的练习7.40中曾经选择并编写了一个类，你认为它应该含有关系运算符吗？如果是，实现它们；如果不是，请解释原因。







