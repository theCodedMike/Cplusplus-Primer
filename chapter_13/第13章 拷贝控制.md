# 第13章 拷贝控制
## 13.1 拷贝、赋值与销毁
**拷贝控制操作**包括：
- 拷贝构造函数：如果一个构造函数的第1个参数是自身类类型的引用，且任何额外参数都有默认值，则此构造函数是**拷贝构造函数**
- 拷贝赋值运算符：一个名为operator=的函数
- 移动构造函数
- 移动赋值运算符
- 析构函数：释放对象使用的资源，并销毁对象的非static数据成员

如果一个类没有定义这些拷贝控制成员，编译器会自动为它定义缺失的操作。

### 13.1.1 拷贝构造函数
拷贝构造函数通常不应该是explicit的

**拷贝初始化**在下列情况时发生：
- 用=定义变量
- 将一个对象作为实参传递给一个非引用类型的形参
- 从一个返回类型为非引用类型的函数返回一个对象
- 用花括号列表初始化一个数组中的元素或一个聚合类中的成员
- 标准库容器使用insert或push操作

### 13.1.2 拷贝赋值运算符
赋值运算符通常应返回一个指向其左侧运算对象的引用

### 13.1.3 析构函数
一个特定的类，只有一个析构函数

在析构函数中，首先执行函数体，然后销毁成员，成员按初始化顺序的逆序销毁

析构函数在下列情况会被调用：
- 变量在离开其作用域时被销毁
- 当一个对象被销毁时，其成员被销毁
- 容器被销毁时，其元素被销毁
- 对于动态分配的对象，当对指向它的指针应用delete运算符时被销毁
- 对于临时对象，当创建它的完整表达式结束时被销毁

### 13.1.4 三/五法则
如果一个类需要一个析构函数，那它基本需要一个拷贝构造函数和一个拷贝赋值运算符

如果一个类需要一个拷贝构造函数，那它基本需要一个拷贝赋值运算符，反之亦然

### 13.1.5 使用=default
添加一个=default声明，会告诉编译器生成合成的版本。

### 13.1.6 阻止拷贝
`=delete`须出现在函数第1次声明的时候

析构函数不应该使用`=delete`

如果一个类有数据成员不能默认构造、拷贝、赋值或销毁，则对应的成员函数将被定义为删除的

在C++11新标准发布之前，类是通过将拷贝构造函数、拷贝赋值运算符声明为private来阻止拷贝

## 13.2 拷贝控制和资源管理
### 13.2.1 行为像值的类
当你编写赋值运算符时，有2点需要注意：
- 如果将一个对象赋予它自身，赋值运算符必须能正确工作
- 大多数赋值运算符组合了析构函数和拷贝构造函数的工作


### 13.2.2 定义行为像指针的类

## 13.3 交换操作

## 13.4 拷贝控制示例

## 13.5 动态内存管理类

## 13.6 对象移动
### 13.6.1 右值引用
### 13.6.2 移动构造函数和移动赋值运算符
### 13.6.3 右值引用和成员函数





## 第13章 练习题
### 13.1.1节练习
<b>练习13.1</b> 拷贝构造函数是什么？什么时候使用它？

<b>练习13.2</b> 解释为什么下面的声明是非法的：
```c++
Sales_data::Sales_data(Sales_data rhs);
```
<b>练习13.3</b> 当我们拷贝一个StrBlob时，会发生什么？拷贝一个StrBlobPtr呢？

<b>练习13.4</b> 假定Point是一个类类型，它有一个public的拷贝构造函数，指出下面程序片段中哪些地方使用了拷贝构造函数：
```c++
Point global;
Point foo_bar(Point arg)
{
    Point local = arg, *heap = new Point(global);
    *heap = local;
    Point pa[4] = {local, *heap};
    return *heap;
}
```
<b>练习13.5</b> 给定下面的类框架，编写一个拷贝构造函数，拷贝所有成员。你的构造函数应该动态分配一个新的string，并将对象拷贝到ps指向的位置，
而不是ps本身的位置。
```c++
class HasPtr {
public:
    HasPtr(const std::string &s = std::string()):
        ps(new std::string(s)), i(0) { }
private:
    std::string *ps;
    int i;
}
```

### 13.1.2节练习
<b>练习13.6</b> 拷贝赋值运算符是什么？什么时候使用它？合成拷贝赋值运算符完成什么工作？什么时候会生成合成拷贝赋值运算符？

<b>练习13.7</b> 当我们将一个StrBlob赋值给另一个StrBlob时，会发生什么？赋值StrBlobPtr呢？

<b>练习13.8</b> 为13.1.1节练习13.5中的HasPtr类编写赋值运算符。类似拷贝构造函数，你的赋值运算符应该将对象拷贝到ps指向的位置。

### 13.1.3节练习
<b>练习13.9</b> 析构函数是什么？合成析构函数完成什么工作？什么时候会生成合成析构函数？

<b>练习13.10</b> 当一个StrBlob对象销毁时会发生什么？一个StrBlobPtr对象销毁时呢？

<b>练习13.11</b> 为前面练习中的HasPtr类添加一个析构函数。

<b>练习13.12</b> 在下面的代码片段中发发生几次析构函数调用？
```c++
bool fcn(const Sales_data *trans, Sales_data accum)
{
    Sales_data item1(*trans), item2(accum);
    return item1.isbn() != item2.isbn();
}
```
<b>练习13.13</b> 理解拷贝控制成员和构造函数的一个好方法是定义一个简单的类，为该类定义这些成员，每个成员都打印出自己的名字：
```c++
struct X {
    x() { cout << "X()" << endl; }
    X(const X&) { cout << "X(const X&)" << endl; }
};
```
给X添加拷贝赋值运算符和析构函数，并编写一个程序以不同方式使用X的对象：将它们作为非引用和引用参数传递；动态分配它们；将它们存放于容器中；等等。
观察程序的输出，直到你确认理解了什么时候会使用拷贝控制成员，以及为什么会使用它们。当你观察程序输出时，记住编译器可以略过对拷贝构造函数的调用。

### 13.1.4节练习
<b>练习13.14</b> 假定numbered是一个类，它有一个默认构造函数，能为每个对象生成一个唯一的序号，保存在名为mysn的数据成员中。假定numbered使用合成的拷贝控制成员，并给定如下函数：
```c++
void f(numbered s) {
    cout << s.mysn << endl;
}
```
则下面代码输出什么内容？
```c++
numbered a, b = a, c = b;
f(a); f(b); f(c);
```
<b>练习13.15</b> 假定numbered定义了一个拷贝构造函数，能生成一个新的序号。这会改变上一题中调用的输出结果吗？如果会改变，为什么？新的输出结果是什么？

<b>练习13.16</b> 如果f中的参数是const numbered&，将会怎样？这会改变输出结果吗？如果会改变，为什么？新的输出结果是什么？

<b>练习13.17</b> 分别编写前3题中所描述的numbered和f，验证你是否正确预测了输出结果。

### 13.1.6节练习
<b>练习13.18</b> 定义一个Employee类，它包含雇员的姓名和唯一的雇员证号。为这个类定义默认构造函数，以及接受一个表示雇员姓名的string的构造函数。
每个构造函数应该通过递增一个static数据成员来生成一个唯一的证号。

<b>练习13.19</b> 你的Employee类需要定义它自己的拷贝控制成员吗？如果需要，为什么？如果不需要，为什么？实现你认为Employee需要的拷贝控制成员。

<b>练习13.20</b> 解释当我们拷贝、赋值或销毁TextQuery和QueryResult类对象时会发生什么。

<b>练习13.21</b> 你认为TextQuery和QueryResult类需要定义它们自己版本的拷贝控制成员吗？如果需要，为什么？如果不需要，为什么？实现你认为这2个类
需要的拷贝控制操作。

### 13.2节练习
<b>练习13.22</b> 假定我们希望HasPtr的行为像一个值，即对于对象所指向的string成员，每个对象都有一份自己的拷贝。我们将在下一节介绍拷贝控制成员的定义。
但是，你已经学习了定义这些成员所需的所有知识。在继续学习下一节之前，为HasPtr编写拷贝构造函数和拷贝赋值运算符。

### 13.2.1节练习
<b>练习13.23</b> 比较上一节练习中你编写的拷贝控制成员和这一节的代码。确定你理解了你的代码和我们的代码之间的差异。

<b>练习13.24</b> 如果本节中的HasPtr版本未定义析构函数，将会发生什么？如果未定义拷贝构造函数，将会发生什么？

<b>练习13.25</b> 假定希望帝国一StrBlob的类值版本，而且希望继续使用shared_ptr，这样我们的StrBlobPtr类就仍能使用指向vector的weak_ptr了。
你修改后的类将需要一个拷贝构造函数和一个拷贝赋值运算符，但不需要析构函数。解释拷贝构造函数和拷贝赋值运算符必须要做什么。解释为什么不需要析构函数。

<b>练习13.26</b> 对上一题中描述的StrBlob类，编写你自己的版本。


### 13.2.2节练习
<b>练习13.27</b> 定义你自己的使用引用计数版本的HasPtr。

<b>练习13.28</b> 给定下面的类，为其实现一个默认构造函数和必要的拷贝控制成员。














