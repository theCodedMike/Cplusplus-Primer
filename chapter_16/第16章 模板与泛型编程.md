# 第16章 模板与泛型编程
## 16.1 定义模板
### 16.1.1 函数模板
非类型模板参数的模板实参必须是常量表达式。

函数模板可以声明为`inline`或`constexpr`的，如下所示:
```text
template <typename T> inline T min(const T& a, const T& b) { //... }
```
函数模板和类模板成员函数的定义通常放在头文件中。

### 16.1.2 类模板
一个类模板的每个实例都会形成一个独立的类。

在一个类模板的作用域内，我们可以直接使用模板名而不必指定模板实参。

### 16.1.3 模板参数
当我们希望通知编译器一个名字表示类型时，须使用关键字`typename`，而不能用`class`。

### 16.1.4 成员模板
### 16.1.5 控制实例化
### 16.1.6 效率与灵活性

## 16.2 模板实参推断
### 16.2.1 类型转换与模板类型参数
### 16.2.2 函数模板显式实参
### 16.2.3 尾置返回类型与类型转换
### 16.2.4 函数指针和实参推断
### 16.2.5 模板实参推断和引用
### 16.2.6 理解std::move
### 16.2.7 转发

## 16.3 重载与模板
## 16.4 可变参数模板
### 16.4.1 编写可变参数函数模板
### 16.4.2 包扩展
### 16.4.3 转发参数包

## 16.5 模板特例化





## 第16章 练习题
### 16.1.1节练习
<b>练习16.1</b> 给出实例化的定义。

<b>练习16.2</b> 编写并测试你自己版本的compare函数。

<b>练习16.3</b> 对2个Sales_data对象调用你的compare函数，观察编译器在实例化过程中如何处理错误。

<b>练习16.4</b> 编写行为类似标准库find算法的模板。函数需要2个模板类型参数，一个表示函数的迭代器参数，另一个表示值的类型。使用你的函数在一个vector<int>
和list<string>中查找给定值。

<b>练习16.5</b> 为6.2.4节(第195页)中的print函数编写模板版本，它接受一个数组的引用，能处理任意大小、任意元素类型的数组。

<b>练习16.6</b> 你认为接受一个数组实参的标准库函数begin和end是如何工作的？定义你自己版本的begin和end。

<b>练习16.7</b> 编写一个constexpr模板，返回给定数组的大小。

<b>练习16.8</b> 在第97页的"关键概念"中，我们注意到，C++程序员喜欢使用!=而不喜欢<。解释这个习惯的原因。


### 16.1.2节练习
<b>练习16.9</b> 什么是函数模板？为什么是类模板？

<b>练习16.10</b> 当一个类模板被实例化时，会发生什么？

<b>练习16.11</b> 下面List的定义是错误的。应如何修正它？
```c++
template <typename elemType> class ListItem;
template <typename elemType> class List {
public:
    List<elemType>();
    List<elemType>(const List<elemType> &);
    List<elemType>& operator=(const List<elemType> &);
    ~List();
    void insert(ListItem *ptr, elemType value);
private:
    ListItem *front, *end;
}
```
<b>练习16.12</b> 编写你自己版本的Blob和BlobPtr模板，包含书中未定义的多个const成员。

<b>练习16.13</b> 解释你为BlobPtr的相等和关系运算符选择哪种类型的友好关系？

<b>练习16.14</b> 编写Screen类模板，用非类型参数定义Screen的高和宽。

<b>练习16.15</b> 为你的Screen模板实现输入和输出运算符。Screen类需要哪些友元（如果需要的话）来令输入和输出运算符正确工作？解释每个友元声明（如果有的话）
为什么是必须要的。

<b>练习16.16</b>将StrVec类（参见13.5节，第465页）重写为模板，命名为Vec。


### 16.1.3节练习
<b>练习16.17</b> 声明为typename的类型参数和声明为class的类型参数有什么不同（如果有的话）？什么时候必须使用typename?

<b>练习16.18</b> 解释下面每个函数模板声明并指出它们是否非法，更正你发现的每个错误。
```text
(a) template <typename T, U, typename V> void f1(T, U, V);
(b) template <typename T> T f2(int &T);
(c) inline template <typename T> T foo(T, unsigned int *);
(d) template <typename T> f4(T, T);
(e) typedef char Ctype;
    template <typename Ctype> Ctype f5(Ctype a);
```
<b>练习16.19</b> 编写函数，接受一个容器的引用，打印容器中的元素。使用容器的size_type和size成员来控制打印元素的循环。

<b>练习16.20</b> 重写上一题的函数，使用begin和end返回的迭代器来控制循环。


### 16.1.4节练习
<b>练习16.21</b> 编写你自己的DebugDelete版本。

<b>练习16.22</b> 修改12.3节(第430页)中你的TextQuery程序，令shared_ptr成员使用DebugDelete作为它们的删除器(参见12.1.4节，第415页)。

<b>练习16.23</b>预测在你爹查询主程序中何时会执行调用运算符。如果你的预测和实际不符，请说明原因。

<b>练习16.24</b> 为你的Blob模板添加一个构造函数，它接受2个迭代器。


### 16.1.5节练习
<b>练习16.25</b> 解释下面这些声明的含义：
```c++
extern template class vector<string>;
template class vector<Sales_data>;
```
<b>练习16.26</b> 假设NoDefault是一个没有默认构造函数的类，我们可以显式实例化vector<NoDefault>嘛？如果不可以，为什么？

<b>练习16.27</b> 对下面每条带标签的语句，解释发生了什么样的实例化（如果有的话）。如果一个模板被实例化，解释为什么？如果没有，解释为什么没有。
```c++
template <typename T> class Stack {};
void f1(Stack<char>);                 // (a)
class Exercise {
    Stack<double> &rsd;               // (b)
    Stack<int> si;                    // (c)
};
int main() {
    Stack<char> *sc;                  // (d)
    f1(*sc);                          // (e)
    int iObj = sizeof(Stack<string>); // (f)
}
```

### 16.1.6节练习
<b>练习16.28</b> 编写你自己版本的shared_ptr和unique_ptr。

<b>练习16.29</b> 编写你的Blob类，用你自己的shared_ptr代替标准库中的版本。

<b>练习16.30</b> 重新运行你的一些程序，验证你的shared_ptr类和修改后的Blob类。

<b>练习16.31</b> 如果我们将DebugDelete与unique_ptr一起使用，解释编译器将删除器处理为内联形式的可能方式。







