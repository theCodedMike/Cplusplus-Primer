# 第16章 模板与泛型编程
## 16.1 定义模板
### 16.1.1 函数模板
非类型模板参数的模板实参必须是常量表达式。

函数模板可以声明为`inline`或`constexpr`的，如下所示:
```text
template <typename T> inline T min(const T& a, const T& b) { //... }
```
函数模板和类模板成员函数的定义通常放在头文件中。




### 16.1.2 类模板
### 16.1.3 模板参数
### 16.1.4 成员模板
### 16.1.5 控制实例化
### 16.1.6 效率与灵活性

## 16.2 模板实参推断
### 16.2.1 类型转换与模板类型参数
### 16.2.2 函数模板显式实参
### 16.2.3 尾置返回类型与类型转换
### 16.2.4 函数指针和实参推断
### 16.2.5 模板实参推断和引用
### 16.2.6 理解std::move
### 16.2.7 转发

## 16.3 重载与模板
## 16.4 可变参数模板
### 16.4.1 编写可变参数函数模板
### 16.4.2 包扩展
### 16.4.3 转发参数包

## 16.5 模板特例化





## 第16章 练习题
### 16.1.1节练习
<b>练习16.1</b> 给出实例化的定义。

<b>练习16.2</b> 编写并测试你自己版本的compare函数。

<b>练习16.3</b> 对2个Sales_data对象调用你的compare函数，观察编译器在实例化过程中如何处理错误。

<b>练习16.4</b> 编写行为类似标准库find算法的模板。函数需要2个模板类型参数，一个表示函数的迭代器参数，另一个表示值的类型。使用你的函数在一个vector<int>
和list<string>中查找给定值。

<b>练习16.5</b> 为6.2.4节(第195页)中的print函数编写模板版本，它接受一个数组的引用，能处理任意大小、任意元素类型的数组。

<b>练习16.6</b> 你认为接受一个数组实参的标准库函数begin和end是如何工作的？定义你自己版本的begin和end。

<b>练习16.7</b> 编写一个constexpr模板，返回给定数组的大小。

<b>练习16.8</b> 在第97页的"关键概念"中，我们注意到，C++程序员喜欢使用!=而不喜欢<。解释这个习惯的原因。
<b>练习16.9</b> 