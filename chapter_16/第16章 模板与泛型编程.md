# 第16章 模板与泛型编程
## 16.1 定义模板
### 16.1.1 函数模板
非类型模板参数的模板实参必须是常量表达式。

函数模板可以声明为`inline`或`constexpr`的，如下所示:
```text
template <typename T> inline T min(const T& a, const T& b) { //... }
```
函数模板和类模板成员函数的定义通常放在头文件中。

### 16.1.2 类模板
一个类模板的每个实例都会形成一个独立的类。

在一个类模板的作用域内，我们可以直接使用模板名而不必指定模板实参。

### 16.1.3 模板参数
当我们希望通知编译器一个名字表示类型时，须使用关键字`typename`，而不能用`class`。

### 16.1.4 成员模板
### 16.1.5 控制实例化
### 16.1.6 效率与灵活性

## 16.2 模板实参推断
### 16.2.1 类型转换与模板类型参数
将实参转递给带模板类型的函数形参时，能够自动应用的类型转换只有const转换及数组或函数到指针的转换。

### 16.2.2 函数模板显式实参
显式模板实参按由左至右的顺序与对应的模板参数匹配：第1个模板实参与第1个模板参数匹配，第2个模板实参与第2个参数匹配，以此类推。

### 16.2.3 尾置返回类型与类型转换
### 16.2.4 函数指针和实参推断
### 16.2.5 模板实参推断和引用
引用折叠只能应用于间接创建的引用的引用，如类型别名或模板参数。对于一个给定类型X：
- X& &、X& &&和X&& &都折叠成类型X&
- 类型X&& &&折叠成X&&

### 16.2.6 理解std::move
使用`static_cast`将一个左值转换为一个右值引用是合法的。

### 16.2.7 转发
当用于一个指向模板参数类型的右值引用函数参数(T&&)时，std::forward会保持实参类型的所有细节。

## 16.3 重载与模板
当有多个重载模板对一个调用提供同样好的匹配时，应选择最特例化的版本。

对于一个调用，如果一个非函数模板与一个函数模板提供同样好的匹配，则选择非模板版本。

## 16.4 可变参数模板
```c++
// Args是一个模板参数包；rest是一个函数参数包
// Args表示0或多个模板类型参数
// rest表示0或多个函数参数
template <typename T, typename... Args>
void foo(const T &t, const Args &... rest);
```
### 16.4.1 编写可变参数函数模板
### 16.4.2 包扩展
### 16.4.3 转发参数包

## 16.5 模板特例化
特例化的本质是实例化一个模板，而非重载它，因此，特例化不影响函数匹配。




## 第16章 练习题
### 16.1.1节练习
<b>练习16.1</b> 给出实例化的定义。

<b>练习16.2</b> 编写并测试你自己版本的compare函数。

<b>练习16.3</b> 对2个Sales_data对象调用你的compare函数，观察编译器在实例化过程中如何处理错误。

<b>练习16.4</b> 编写行为类似标准库find算法的模板。函数需要2个模板类型参数，一个表示函数的迭代器参数，另一个表示值的类型。使用你的函数在一个vector<int>
和list<string>中查找给定值。

<b>练习16.5</b> 为6.2.4节(第195页)中的print函数编写模板版本，它接受一个数组的引用，能处理任意大小、任意元素类型的数组。

<b>练习16.6</b> 你认为接受一个数组实参的标准库函数begin和end是如何工作的？定义你自己版本的begin和end。

<b>练习16.7</b> 编写一个constexpr模板，返回给定数组的大小。

<b>练习16.8</b> 在第97页的"关键概念"中，我们注意到，C++程序员喜欢使用!=而不喜欢<。解释这个习惯的原因。


### 16.1.2节练习
<b>练习16.9</b> 什么是函数模板？为什么是类模板？

<b>练习16.10</b> 当一个类模板被实例化时，会发生什么？

<b>练习16.11</b> 下面List的定义是错误的。应如何修正它？
```c++
template <typename elemType> class ListItem;
template <typename elemType> class List {
public:
    List<elemType>();
    List<elemType>(const List<elemType> &);
    List<elemType>& operator=(const List<elemType> &);
    ~List();
    void insert(ListItem *ptr, elemType value);
private:
    ListItem *front, *end;
}
```
<b>练习16.12</b> 编写你自己版本的Blob和BlobPtr模板，包含书中未定义的多个const成员。

<b>练习16.13</b> 解释你为BlobPtr的相等和关系运算符选择哪种类型的友好关系？

<b>练习16.14</b> 编写Screen类模板，用非类型参数定义Screen的高和宽。

<b>练习16.15</b> 为你的Screen模板实现输入和输出运算符。Screen类需要哪些友元（如果需要的话）来令输入和输出运算符正确工作？解释每个友元声明（如果有的话）
为什么是必须要的。

<b>练习16.16</b>将StrVec类（参见13.5节，第465页）重写为模板，命名为Vec。


### 16.1.3节练习
<b>练习16.17</b> 声明为typename的类型参数和声明为class的类型参数有什么不同（如果有的话）？什么时候必须使用typename?

<b>练习16.18</b> 解释下面每个函数模板声明并指出它们是否非法，更正你发现的每个错误。
```text
(a) template <typename T, U, typename V> void f1(T, U, V);
(b) template <typename T> T f2(int &T);
(c) inline template <typename T> T foo(T, unsigned int *);
(d) template <typename T> f4(T, T);
(e) typedef char Ctype;
    template <typename Ctype> Ctype f5(Ctype a);
```
<b>练习16.19</b> 编写函数，接受一个容器的引用，打印容器中的元素。使用容器的size_type和size成员来控制打印元素的循环。

<b>练习16.20</b> 重写上一题的函数，使用begin和end返回的迭代器来控制循环。


### 16.1.4节练习
<b>练习16.21</b> 编写你自己的DebugDelete版本。

<b>练习16.22</b> 修改12.3节(第430页)中你的TextQuery程序，令shared_ptr成员使用DebugDelete作为它们的删除器(参见12.1.4节，第415页)。

<b>练习16.23</b>预测在你爹查询主程序中何时会执行调用运算符。如果你的预测和实际不符，请说明原因。

<b>练习16.24</b> 为你的Blob模板添加一个构造函数，它接受2个迭代器。


### 16.1.5节练习
<b>练习16.25</b> 解释下面这些声明的含义：
```c++
extern template class vector<string>;
template class vector<Sales_data>;
```
<b>练习16.26</b> 假设NoDefault是一个没有默认构造函数的类，我们可以显式实例化vector<NoDefault>嘛？如果不可以，为什么？

<b>练习16.27</b> 对下面每条带标签的语句，解释发生了什么样的实例化（如果有的话）。如果一个模板被实例化，解释为什么？如果没有，解释为什么没有。
```c++
template <typename T> class Stack {};
void f1(Stack<char>);                 // (a)
class Exercise {
    Stack<double> &rsd;               // (b)
    Stack<int> si;                    // (c)
};
int main() {
    Stack<char> *sc;                  // (d)
    f1(*sc);                          // (e)
    int iObj = sizeof(Stack<string>); // (f)
}
```

### 16.1.6节练习
<b>练习16.28</b> 编写你自己版本的shared_ptr和unique_ptr。

<b>练习16.29</b> 编写你的Blob类，用你自己的shared_ptr代替标准库中的版本。

<b>练习16.30</b> 重新运行你的一些程序，验证你的shared_ptr类和修改后的Blob类。

<b>练习16.31</b> 如果我们将DebugDelete与unique_ptr一起使用，解释编译器将删除器处理为内联形式的可能方式。


### 16.2.1节练习
<b>练习16.32</b> 在模板实参推断过程中发生了什么？ 

<b>练习16.33</b> 指出在模板实参推断过程中允许对函数实参进行的2种类型转换。

<b>练习16.34</b> 对下面的代码解释每个调用是否合法。如果合法，T的类型是什么？如果不合法，为什么？
```text
template <typename T> int compare(const T &, const T &);
(a) compare("hi", "world");
(b) compare("bye", "dad");
```
<b>练习16.35</b> 下面调用中哪些是错误的(如果有的话)？如果调用合法，T的类型是什么？如果调用不合法，问题在哪里？
```text
template <typename T> T calc(T, int);
template <typename T> T fcn(T, T);
double d; float f; char c;
(a) calc(c, 'c');                 (b) calc(d, f);
(c) fcn(c, 'c');                  (d) fcn(d, f);
```
<b>练习16.36</b> 进行下面的调用会发生什么：
```text
template <typename T> void f1(T, T);
template <typename T1, typename T2> void f2(T1, T2);
int i = 0, j = 42, *p1 = &i, *p2 = &j;
const int *cp1 = &i, *cp2 = &j;
(a) f1(p1, p2);          (b) f2(p1, p2);          (c) f1(cp1, cp2);
(d) f2(cp1, cp2);        (e) f1(p1, cp1);         (e) f2(p1, cp1);
```

### 16.2.2节练习
<b>练习16.37</b> 标准库max函数有2个参数，它返回实参中的较大者。此函数有一个模板类型参数。你能在调用max时传递给它一个int和一个double嘛？
如何可以，如何做？如果不可以，为什么？

<b>练习16.38</b> 当我们调用make_shared时(参见12.1.1节，第401页)，必须提供一个显式模板实参。解释为什么需要显式模板实参以及它是如何使用的。

<b>练习16.39</b> 对16.1.1节(第578页)中的原始版本的compare函数，使用一个显式模板实参，使得可以向函数传递2个字符串字面常量。


### 16.2.3节练习
<b>练习16.40</b> 下面的函数是否合法？如果不合法，为什么？如何合法，对可以传递的实参类型有什么限制(如果有的话)？返回类型是什么？
```c++
template <typename It>
auto fcn3(It beg, It end) -> decltype(*beg + 0) {
    // 处理序列
    return *beg; // 返回序列中一个元素的拷贝
}
```
<b>练习16.41</b> 编写一个新的sum版本，它的返回类型保证足够大，足以容纳加法结果。


### 16.2.5节练习
<b>练习16.42</b> 对下面每个调用，确定T和val的类型：
```text
template <typename T> void g(T&& val);
int i = 0; const int ci = i;
(a) g(i);      (b) g(ci);       (c) g(i * ci);
```
<b>练习16.43</b> 使用上一题定义的函数，如果我们调用g(i = ci)，g的模板参数将是什么？

<b>练习16.44</b> 使用与第一题中相同的3个调用，如果g的函数参数声明为T(而不是T&&)，确定T的类型。如果g的函数参数是const T&呢？

<b>练习16.45</b> 给定下面的模板，如果我们对一个像42这样的字面常量调用g，解释会发生什么？如果我们对一个int类型的变量调用g呢？
```c++
template <typename T> void g(T&& val) {
    vector<T> v;
}
```

### 16.2.6节练习
<b>练习16.46</b> 解释下面的循环，它来自13.5节(第469页)中的StrVec::reallocate:
```c++
for (size_t i = 0; i != size(); ++i)
    alloc.construct(dest++, std::move(*elem++));
```

### 16.2.7节练习
<b>练习16.47</b> 编写你自己版本的翻转函数，通过调用接受左值和右值引用参数的函数来测试它。


### 16.3节练习
<b>练习16.48</b> 编写你自己版本的debug_rep函数。

<b>练习16.49</b> 解释下面每个调用会发生什么：
```c++
template <typename T> void f(T);
template <typename T> void f(const T*);
template <typename T> void g(T);
template <typename T> void g(T *);

int i = 42, *p = &i;
const int ci = 0, *p2 = &ci;
g(42);  g(p);  g(ci);  g(p2);
f(42);  f(p);  f(ci);  f(p2);
```
<b>练习16.50</b> 定义上一个练习中的函数，令它们打印一条身份信息。运行该练习中的代码。如果函数调用的行为与你预期不符，确定你理解了原因。


### 16.4节练习
<b>练习16.51</b> 调用本节中的每个foo，确定sizeof...(Args)和sizeof...(rest)分别返回什么。

<b>练习16.52</b> 编写一个程序验证上一题的答案。


### 16.4.1节练习
<b>练习16.53</b> 编写你自己版本的print函数，并打印一个、两个或五个实参来测试它，要打印的每个实参都应有不同的类型。

<b>练习16.54</b> 如果我们对一个没有<<运算符的类型调用print，会发生什么？

<b>练习16.55</b> 如果我们的可变参数版本print的定义之后声明非可变参数版本，解释可变参数的版本会如何执行。


### 16.4.2节练习
<b>练习16.56</b> 编写并测试可变参数版本的errorMsg.

<b>练习16.57</b> 比较你的可变参数版本的errorMsg和6.2.6节(第198页)中的error_msg函数。2种方法的优点和缺点各是什么？


### 16.4.3节练习
<b>练习16.58</b> 为你的StrVec类及你为16.1.2节(第591页)练习中编写的Vec类添加emplace_back函数。

<b>练习16.59</b> 假定s是一个string，解释调用svec.emplace_back(s)会发生什么。

<b>练习16.60</b> 解释make_shared(参见12.1.1节,第401页)是如何工作的。

<b>练习16.61</b> 定义你自己版本的make_shared。


### 16.5节练习
<b>练习16.62</b> 定义你自己版本的hash<Sales_data>，并定义一个Sales_data对象的unordered_multiset。将多条交易记录保存到容器中，并打印其内容。

<b>练习16.63</b> 定义一个函数模板，统计一个给定值在一个vector中出现的次数。测试你的函数，分别传递给它一个double的vector，一个int的vector以及
一个string的vector。

<b>练习16.64</b> 为上一题中的模板编写特例化版本来处理vector<const char *>，编写程序使用这个特例化版本。

<b>练习16.65</b> 在16.3节(第617页)中我们定义了2个重载的debug_rep版本，一个接受const char *参数，另一个接受char *参数。将这2个函数重写为特例化版本。

<b>练习16.66</b> 重载debug_rep函数与特例化相比，有何优点和缺点？

<b>练习16.67</b> 定义特例化版本会影响debug_rep的函数匹配嘛？如果不影响，为什么？


