# 第9章 顺序容器
## 9.1 顺序容器概述
<table>
    <tr>
        <th colspan="2">表9.1 顺序容器类型</th>
    </tr>
    <tr>
        <td>vector</td> <td>可变大小数组，支持快速随机访问，在尾部之外的位置插入或删除元素可能很慢</td>
    </tr>
    <tr>
        <td>array</td> <td>固定大小数组，支持快速随机访问，不能添加或删除元素</td>
    </tr>
    <tr>
        <td>list</td> <td>双向链表，只支持双向顺序访问。在list中任何位置进行插入/删除操作速度都很快</td>
    </tr>
    <tr>
        <td>forward_list</td> <td>单项链表，只支持单向顺序访问</td>
    </tr>
    <tr>
        <td>string</td> <td>与vector类似，专门用于保存字符</td>
    </tr>
    <tr>
        <td>string_view</td> <td>c++17引入，只读操作</td>
    </tr>
    <tr>
        <td>stack</td> <td>栈</td>
    </tr>
    <tr>
        <td>queue</td> <td>队列</td>
    </tr>
    <tr>
        <td>deque</td> <td>双端队列，支持快速随机访问，在头尾位置插入/删除速度很快</td>
    </tr>
    <tr>
        <td>priority_deque</td> <td>优先队列</td>
    </tr>
    <tr>
        <td>bitset</td> <td></td>
    </tr>
</table>

## 9.2 容器库概览
<table>
    <tr>
        <th colspan="2">表9.2 容器操作</th>
    </tr>
    <tr>
        <td><b>类型别名</b></td> <td></td>
    </tr>
    <tr>
        <td>iterator</td> <td>此容器类型的迭代器类型</td>
    </tr>
    <tr>
        <td>const_iterator</td> <td>可以读取元素，但不能修改元素的迭代器类型</td>
    </tr>
    <tr>
        <td>size_type</td> <td>无符号整数类型，足够保存此种容器类型最大的大小</td>
    </tr>
    <tr>
        <td>difference_type</td> <td>带符号整数类型，足够保存2个迭代器之间的距离</td>
    </tr>
    <tr>
        <td>value_type</td> <td>元素类型</td>
    </tr>
    <tr>
        <td>reference</td> <td>元素的左值类型，与value_type&含义相同</td>
    </tr>
    <tr>
        <td>const_reference</td> <td>元素的const左值类型，与const value_type&含义相同</td>
    </tr>
    <tr>
        <td><b>构造函数</b></td> <td></td>
    </tr>
    <tr>
        <td>C c</td> <td>默认构造函数，构造空容器</td>
    </tr>
    <tr>
        <td>C c1(c2)</td> <td>构造c2的拷贝c1</td>
    </tr>
    <tr>
        <td>C c(begin, end)</td> <td>构造c，将迭代器b和e指定范围内的元素拷贝到c</td>
    </tr>
    <tr>
        <td>C c(a, b, c...)</td> <td>列表初始化c</td>
    </tr>
    <tr>
        <td><b>赋值与swap</b></td> <td></td>
    </tr>
    <tr>
        <td>c1 = c2</td> <td>将c1中的元素替换成c2中的元素</td>
    </tr>
    <tr>
        <td>c1 = {a, b, c...}</td> <td>将c1中的元素替换成列表中的元素(不适用于array)</td>
    </tr>
    <tr>
        <td>a.swap(b)</td> <td>交换a和b的元素</td>
    </tr>
    <tr>
        <td>swap(a, b)</td> <td>与a.swap(b)等价</td>
    </tr>
    <tr>
        <td><b>大小</b></td> <td></td>
    </tr>
    <tr>
        <td>c.size()</td> <td>c中元素的数目(不支持forward_list)</td>
    </tr>
    <tr>
        <td>c.max_size()</td> <td>c可保存的最大元素数目</td>
    </tr>
    <tr>
        <td>c.empty()</td> <td>判空</td>
    </tr>
    <tr>
        <td><b>添加/删除元素(不适用于array)</b></td> <td>注：在不同容器中，以下操作的接口都不同</td>
    </tr>
    <tr>
        <td>c.insert(args)</td> <td>将args中的元素拷贝到c</td>
    </tr>
    <tr>
        <td>c.emplace(inits)</td> <td>使用inits构造c中的一个元素</td>
    </tr>
    <tr>
        <td>c.erase(args)</td> <td>删除args指定的元素</td>
    </tr>
    <tr>
        <td>c.clear()</td> <td>删除c中的所有元素</td>
    </tr>
    <tr>
        <td><b>关系运算符</b></td> <td></td>
    </tr>
    <tr>
        <td>==、!=</td> <td>所有容器都支持相等(不等)运算符</td>
    </tr>
    <tr>
        <td><、<=、>、>=</td> <td>关系运算符(无序关联容器不支持)</td>
    </tr>
    <tr>
        <td><b>获取迭代器</b></td> <td></td>
    </tr>
    <tr>
        <td>c.begin()、c.end()</td> <td>返回指向c的首元素和尾元素之后位置的迭代器</td>
    </tr>
    <tr>
        <td>c.cbegin()、c.cend()</td> <td>返回const_iterator</td>
    </tr>
    <tr>
        <td><b>反向容器的额外成员(不支持forward_list)</b></td> <td></td>
    </tr>
    <tr>
        <td>reverse_iterator</td> <td>按逆序寻址元素的迭代器</td>
    </tr>
    <tr>
        <td>const_reverse_iterator</td> <td>不能修改元素的逆序迭代器</td>
    </tr>
    <tr>
        <td>c.rbegin()、c.rend()</td> <td>返回指向c的尾元素和首元素之前位置的迭代器</td>
    </tr>
    <tr>
        <td>c.crbegin()、c.crend()</td> <td>返回const_reverse_iterator</td>
    </tr>
</table>

### 9.2.1 迭代器
### 9.2.2 容器类型成员
### 9.2.3 begin和end成员
### 9.2.4 容器定义和初始化
### 9.2.5 赋值和swap
### 9.2.6 容器大小操作
### 9.2.7 关系运算符

## 9.3 顺序容器操作
### 9.3.1 向顺序容器添加元素
### 9.3.2 访问元素
### 9.3.3 删除元素
### 9.3.4 特殊的forward_list操作
### 9.3.5 改变容器大小
### 9.3.6 容器操作可能使迭代器失效

## 9.4 vector对象是如何增长的

## 9.5 额外的string操作
### 9.5.1 构造string的其他方法
### 9.5.2 改变string的其他方法
### 9.5.3 string搜索操作
### 9.5.4 compare函数
### 9.5.5 数值转换

## 9.6 容器适配器





## 第9章 练习题
### 9.1节练习
<b>练习9.1</b> 对于下面的程序任务，vector、deque和list哪种容器最为合适？解释你选择的理由。如果没有哪一种容器优于其他容器，也请解释理由。
```text
(a) 读取固定数量的单词，将它们按字典顺序插入到容器中。
(b) 读取未知数量的单词，总是将新单词插入到末尾。删除操作在头部进行。
(c) 从一个文件读取未知数量的整数。将这些整数排序，然后将它们打印到标准输出。
```
### 9.2节练习
<b>练习9.2</b> 定义一个list对象，其元素类型是int的deque。

### 9.2.1节练习
<b>练习9.3</b> 构成迭代器范围的迭代器有何限制？

<b>练习9.4</b> 编写函数，接受一对指向vector<int>的迭代器和一个int值。在2个迭代器指定的范围中查找给定的值，返回一个布尔值来指出是否找到。

<b>练习9.5</b> 重写上一题的函数，返回一个迭代器指向找到的元素。注意，程序必须处理未找到给定值的情况。

<b>练习9.6</b> 下面程序有何错误？你应该如何修改它？
```c++
list<int> lst1;
list<int>::iterator iter1 = lst1.begin(), iter2 = lst1.end();

while (iter1 != iter2) /* ... */
```
### 9.2.2节练习
<b>练习9.7</b> 为了索引int的vector中的元素，应该使用什么类型？

<b>练习9.8</b> 为了读取string的list中的元素，应该使用什么类型？如果写入list，又该使用什么类型？

### 9.2.3节练习
<b>练习9.9</b> begin和cbegin这2个函数有什么不同？

<b>练习9.10</b> 下面4个对象分别是什么类型？
```c++
vector<int> v1;
const vector<int> v2;
auto it1 = v1.begin(), it2 = v2.begin();
auto it3 = v1.cbegin(), it4 = v2.cbegin();
```
### 9.2.4节练习
<b>练习9.11</b> 对6种创建和初始化vector对象的方法，每一种都给出一个实例。解释每个vector包含什么值。

<b>练习9.12</b> 对于接受一个容器创建其拷贝的构造函数，和接受2个迭代器创建拷贝的构造函数，解释它们的不同。

<b>练习9.13</b> 如何从一个list<int>初始化一个vector<double>？从一个vector<int>又该如何闯进啊？编写代码测试你的答案。

### 9.2.5节练习
<b>练习9.14</b> 编写程序，将一个list种的char *指针(指向C风格字符串)元素赋值给一个vector中的string。

### 9.2.7节练习
<b>练习9.15</b> 编写程序，判定2个vector<int>是否相等。

<b>练习9.16</b> 重写上一题的程序，比较一个list<int>中的元素和一个vector<int>中的元素。

<b>练习9.17</b> 假定c1和c2是2个容器，下面的比较操作有何限制（如果有的话）？
```c++
if (c1 < c2)
```

