# 第9章 顺序容器
## 9.1 顺序容器概述
<table>
    <tr>
        <th colspan="2">表9.1 顺序容器类型</th>
    </tr>
    <tr>
        <td>vector</td> <td>可变大小数组，支持快速随机访问，在尾部之外的位置插入或删除元素可能很慢</td>
    </tr>
    <tr>
        <td>array</td> <td>固定大小数组，支持快速随机访问，不能添加或删除元素</td>
    </tr>
    <tr>
        <td>list</td> <td>双向链表，只支持双向顺序访问。在list中任何位置进行插入/删除操作速度都很快</td>
    </tr>
    <tr>
        <td>forward_list</td> <td>单项链表，只支持单向顺序访问</td>
    </tr>
    <tr>
        <td>string</td> <td>与vector类似，专门用于保存字符</td>
    </tr>
    <tr>
        <td>string_view</td> <td>c++17引入，只读操作</td>
    </tr>
    <tr>
        <td>stack</td> <td>栈</td>
    </tr>
    <tr>
        <td>queue</td> <td>队列</td>
    </tr>
    <tr>
        <td>deque</td> <td>双端队列，支持快速随机访问，在头尾位置插入/删除速度很快</td>
    </tr>
    <tr>
        <td>priority_deque</td> <td>优先队列</td>
    </tr>
    <tr>
        <td>bitset</td> <td></td>
    </tr>
</table>

## 9.2 容器库概览
<table>
    <tr>
        <th colspan="2">表9.2 容器操作</th>
    </tr>
    <tr>
        <td><b>类型别名</b></td> <td></td>
    </tr>
    <tr>
        <td>iterator</td> <td>此容器类型的迭代器类型</td>
    </tr>
    <tr>
        <td>const_iterator</td> <td>可以读取元素，但不能修改元素的迭代器类型</td>
    </tr>
    <tr>
        <td>size_type</td> <td>无符号整数类型，足够保存此种容器类型最大的大小</td>
    </tr>
    <tr>
        <td>difference_type</td> <td>带符号整数类型，足够保存2个迭代器之间的距离</td>
    </tr>
    <tr>
        <td>value_type</td> <td>元素类型</td>
    </tr>
    <tr>
        <td>reference</td> <td>元素的左值类型，与value_type&含义相同</td>
    </tr>
    <tr>
        <td>const_reference</td> <td>元素的const左值类型，与const value_type&含义相同</td>
    </tr>
    <tr>
        <td><b>构造函数</b></td> <td></td>
    </tr>
    <tr>
        <td>C c</td> <td>默认构造函数，构造空容器</td>
    </tr>
    <tr>
        <td>C c1(c2)</td> <td>构造c2的拷贝c1</td>
    </tr>
    <tr>
        <td>C c(begin, end)</td> <td>构造c，将迭代器b和e指定范围内的元素拷贝到c</td>
    </tr>
    <tr>
        <td>C c(a, b, c...)</td> <td>列表初始化c</td>
    </tr>
    <tr>
        <td><b>赋值与swap</b></td> <td></td>
    </tr>
    <tr>
        <td>c1 = c2</td> <td>将c1中的元素替换成c2中的元素</td>
    </tr>
    <tr>
        <td>c1 = {a, b, c...}</td> <td>将c1中的元素替换成列表中的元素(不适用于array)</td>
    </tr>
    <tr>
        <td>a.swap(b)</td> <td>交换a和b的元素</td>
    </tr>
    <tr>
        <td>swap(a, b)</td> <td>与a.swap(b)等价</td>
    </tr>
    <tr>
        <td><b>大小</b></td> <td></td>
    </tr>
    <tr>
        <td>c.size()</td> <td>c中元素的数目(不支持forward_list)</td>
    </tr>
    <tr>
        <td>c.max_size()</td> <td>c可保存的最大元素数目</td>
    </tr>
    <tr>
        <td>c.empty()</td> <td>判空</td>
    </tr>
    <tr>
        <td><b>添加/删除元素(不适用于array)</b></td> <td>注：在不同容器中，以下操作的接口都不同</td>
    </tr>
    <tr>
        <td>c.insert(args)</td> <td>将args中的元素拷贝到c</td>
    </tr>
    <tr>
        <td>c.emplace(inits)</td> <td>使用inits构造c中的一个元素</td>
    </tr>
    <tr>
        <td>c.erase(args)</td> <td>删除args指定的元素</td>
    </tr>
    <tr>
        <td>c.clear()</td> <td>删除c中的所有元素</td>
    </tr>
    <tr>
        <td><b>关系运算符</b></td> <td></td>
    </tr>
    <tr>
        <td>==、!=</td> <td>所有容器都支持相等(不等)运算符</td>
    </tr>
    <tr>
        <td><、<=、>、>=</td> <td>关系运算符(无序关联容器不支持)</td>
    </tr>
    <tr>
        <td><b>获取迭代器</b></td> <td></td>
    </tr>
    <tr>
        <td>c.begin()、c.end()</td> <td>返回指向c的首元素和尾元素之后位置的迭代器</td>
    </tr>
    <tr>
        <td>c.cbegin()、c.cend()</td> <td>返回const_iterator</td>
    </tr>
    <tr>
        <td><b>反向容器的额外成员(不支持forward_list)</b></td> <td></td>
    </tr>
    <tr>
        <td>reverse_iterator</td> <td>按逆序寻址元素的迭代器</td>
    </tr>
    <tr>
        <td>const_reverse_iterator</td> <td>不能修改元素的逆序迭代器</td>
    </tr>
    <tr>
        <td>c.rbegin()、c.rend()</td> <td>返回指向c的尾元素和首元素之前位置的迭代器</td>
    </tr>
    <tr>
        <td>c.crbegin()、c.crend()</td> <td>返回const_reverse_iterator</td>
    </tr>
</table>

### 9.2.1 迭代器
### 9.2.2 容器类型成员
### 9.2.3 begin和end成员
### 9.2.4 容器定义和初始化
### 9.2.5 赋值和swap
### 9.2.6 容器大小操作
### 9.2.7 关系运算符

## 9.3 顺序容器操作
### 9.3.1 向顺序容器添加元素
### 9.3.2 访问元素
### 9.3.3 删除元素
### 9.3.4 特殊的forward_list操作
<table>
    <tr>
        <th colspan="2">表9.8 在forward_list中插入/删除元素的操作</th>
    </tr>
    <tr style="background-color: darkolivegreen">
        <td>lst.before_begin()</td> <td>返回指向链表首元素之前不存在的元素的迭代器，不能解引用</td>
    </tr>
    <tr style="background-color: darkolivegreen">
        <td>lst.cbefore_begin()</td> <td>返回const_iterator</td>
    </tr>
    <tr style="background-color: slategrey">
        <td>lst.insert_after(p, t)</td> <td>在迭代器p之后的位置插入元素t</td>
    </tr>
    <tr style="background-color: slategrey">
        <td>lst.insert_after(p, n, t)</td> <td>在迭代器p之后的位置插入n个元素t</td>
    </tr>
    <tr style="background-color: slategrey">
        <td>lst.insert_after(p, beg, end)</td> <td>在迭代器p之后的位置插入某个范围的元素</td>
    </tr>
    <tr style="background-color: slategrey">
        <td>lst.insert_after(p, il)</td> <td>在迭代器p之后的位置插入一个初始化列表</td>
    </tr>
    <tr style="background-color: olive">
        <td>emplace_after(p, args)</td> <td>使用args在p指定的位置之后创建一个元素，返回一个指向这个新元素的迭代器</td>
    </tr>
    <tr style="background-color: midnightblue">
        <td>lst.erase_after(p)</td> <td>删除p指向的位置之后的元素</td>
    </tr>
    <tr style="background-color: midnightblue">
        <td>lst.erase_after(beg, end)</td> <td>删除[beg, end)之间的元素</td>
    </tr>
</table>

### 9.3.5 改变容器大小
### 9.3.6 容器操作可能使迭代器失效
向容器中添加元素或删除元素可能会使指向容器元素的指针、引用或迭代器失效。

改变容器大小时，不要缓存end返回的迭代器。

## 9.4 vector对象是如何增长的

## 9.5 额外的string操作
### 9.5.1 构造string的其他方法
### 9.5.2 改变string的其他方法
### 9.5.3 string搜索操作
### 9.5.4 compare函数
### 9.5.5 数值转换

## 9.6 容器适配器





## 第9章 练习题
### 9.1节练习
<b>练习9.1</b> 对于下面的程序任务，vector、deque和list哪种容器最为合适？解释你选择的理由。如果没有哪一种容器优于其他容器，也请解释理由。
```text
(a) 读取固定数量的单词，将它们按字典顺序插入到容器中。
(b) 读取未知数量的单词，总是将新单词插入到末尾。删除操作在头部进行。
(c) 从一个文件读取未知数量的整数。将这些整数排序，然后将它们打印到标准输出。
```
### 9.2节练习
<b>练习9.2</b> 定义一个list对象，其元素类型是int的deque。

### 9.2.1节练习
<b>练习9.3</b> 构成迭代器范围的迭代器有何限制？

<b>练习9.4</b> 编写函数，接受一对指向vector<int>的迭代器和一个int值。在2个迭代器指定的范围中查找给定的值，返回一个布尔值来指出是否找到。

<b>练习9.5</b> 重写上一题的函数，返回一个迭代器指向找到的元素。注意，程序必须处理未找到给定值的情况。

<b>练习9.6</b> 下面程序有何错误？你应该如何修改它？
```c++
list<int> lst1;
list<int>::iterator iter1 = lst1.begin(), iter2 = lst1.end();

while (iter1 != iter2) /* ... */
```
### 9.2.2节练习
<b>练习9.7</b> 为了索引int的vector中的元素，应该使用什么类型？

<b>练习9.8</b> 为了读取string的list中的元素，应该使用什么类型？如果写入list，又该使用什么类型？

### 9.2.3节练习
<b>练习9.9</b> begin和cbegin这2个函数有什么不同？

<b>练习9.10</b> 下面4个对象分别是什么类型？
```c++
vector<int> v1;
const vector<int> v2;
auto it1 = v1.begin(), it2 = v2.begin();
auto it3 = v1.cbegin(), it4 = v2.cbegin();
```
### 9.2.4节练习
<b>练习9.11</b> 对6种创建和初始化vector对象的方法，每一种都给出一个实例。解释每个vector包含什么值。

<b>练习9.12</b> 对于接受一个容器创建其拷贝的构造函数，和接受2个迭代器创建拷贝的构造函数，解释它们的不同。

<b>练习9.13</b> 如何从一个list<int>初始化一个vector<double>？从一个vector<int>又该如何闯进啊？编写代码测试你的答案。

### 9.2.5节练习
<b>练习9.14</b> 编写程序，将一个list种的char *指针(指向C风格字符串)元素赋值给一个vector中的string。

### 9.2.7节练习
<b>练习9.15</b> 编写程序，判定2个vector<int>是否相等。

<b>练习9.16</b> 重写上一题的程序，比较一个list<int>中的元素和一个vector<int>中的元素。

<b>练习9.17</b> 假定c1和c2是2个容器，下面的比较操作有何限制（如果有的话）？
```c++
if (c1 < c2)
```
### 9.3.1节练习
<b>练习9.18</b> 编写程序，从标准输入读取string序列，存入一个deque中。编写一个循环，用迭代器打印deque中的元素。

<b>练习9.19</b> 重写上题的程序，用list替代deque。列出程序要做出哪些改变。

<b>练习9.20</b> 编写程序，从一个list<int>拷贝元素到2个deque中。值未偶数的所有元素都拷贝到一个deque中，而奇数值元素拷贝到另一个deque中。

<b>练习9.21</b> 如果我们将第308页中使用insert返回值将元素添加到list中的循环程序改写为将元素插入到vector中，分析循环将如何工作。

<b>练习9.22</b> 假定iv是一个int的vector，下面的程序存在什么错误？如何修改？
```c++
vector<int>::iterator iter = iv.begin(), mid = iv.begin() + iv.size() / 2;
while(iter != mid)
    if (*iter == some_val)
        iv.insert(iter, 2 * some_val);
```
### 9.3.2节练习
<b>练习9.23</b> 在本节第1个程序中，若c.size()为1，则val1、val2、val3和val4的值会是什么？

<b>练习9.24</b> 编写程序，分别使用at、下标运算符、front和begin提取一个vector中的第1个元素。在一个空的vector上测试你的程序。

### 9.3.3节练习
<b>练习9.25</b> 对于第312页中删除一个范围内的元素的程序，如果elem1和elem2相等会发生什么？
如果elem2是尾后迭代器，或者elem1和elem2都是尾后迭代器，又会发生什么？

<b>练习9.26</b> 使用下面代码定义的ia，将ia拷贝到一个vector和一个list总。使用单迭代器版本的erase从list中删除奇数元素，从vector中删除偶数元素。
```c++
int ia[] = {0, 1, 1, 2, 3, 5, 8, 13, 21, 55, 89};
```
### 9.3.4节练习
<b>练习9.27</b> 编写程序，查找并删除forward_list<int>中的奇数元素。

<b>练习9.28</b> 编写函数，接受一个forward_list<string>和2个string共3个参数。函数应在链表中查找第1个string，并将第2个string插入到紧接着第1个string之后的位置。
若第1个string未在链表中，则将第2个string插入到链表末尾。

### 9.3.5节练习
<b>练习9.29</b> 假定vec包含25个元素，那么vec.resize(100)会做什么？如果接下来调用vec.resize(10)会做什么？

<b>练习9.30</b> 接受单个参数的resize版本对元素类型有什么要求（如果有的话）？

### 9.3.6节练习
<b>练习9.31</b> 第316页中删除偶数值元素并复制奇数值元素的程序不能用于list或forward_list，为什么？修改程序，使之能用于这些类型。

<b>练习9.32</b> 在第316页的程序中，向下面语句这样调用insert是否合法？如果不合法，为什么？
```c++
iter = vi.insert(iter, *iter++);
```
<b>练习9.33</b> 在本节最后一个例子中，如果不将insert的结果赋予begin，将会发生什么？编写程序，去掉此赋值语句，验证你的答案。

<b>练习9.34</b> 假定vi是一个保存int的容器，其中有偶数值也有奇数值，分析下面循环的行为，然后编写程序验证你的分析是否正确。
```c++
iter = vi.begin();
while (iter != vi.end())
    if (*iter % 2)
        iter =  vi.insert(iter, *iter);
    ++iter;
```
### 9.4节练习
<b>练习9.35</b> 解释一个vector的capacity和size的区别。

<b>练习9.36</b> 一个容器的capacity可能小于它的size吗？

<b>练习9.37</b> 为什么list或array没有capacity成员函数？

<b>练习9.38</b> 编写程序，探究在你的标准库实现中，vector是如何增长的。

<b>练习9.39</b> 解释下面程序片段做了什么？
```c++
vector<int> svec;
svec.reserve(1024);
string word;
while (cin >> word)
    svec.push_back(word);
svec.resize(svec.size() + svec.size() / 2);
```
<b>练习9.40</b> 如果上一题中的程序读入了256个词，在resize之后容器的capacity可能是多少？如果读入了512个、1000个或1048个词呢？

### 9.5.1节练习
<b>练习9.41</b> 编写程序，从一个vector<char>初始化一个string。

<b>练习9.42</b> 假定你希望每次读取一个字符存入一个string中，而且知道最少需要读取100个字符，该如何提高程序的性能？

### 9.5.2节练习
<b>练习9.43</b> 编写一个函数，接受3个string参数s、oldVal和newVal。使用迭代器和insert和erase函数将s中所有oldVal替换为newVal。
测试你的程序，用它替换通用的简写形式，如将"tho"替换成"though"，将"thru"替换为"through"。

<b>练习9.44</b> 重写上一题的函数，这次使用一个下标和replace。

<b>练习9.45</b> 编写一个函数，接受一个表示名字的string参数和2个分别表示前缀(如"Mr."或"Ms.")和后缀(如"Jr."和"III")的字符串。使用迭代器和insert
和append函数将前缀和后缀添加到给定的名字中，将生成的新string返回。

<b>练习9.46</b> 重写上一题的函数，这次使用位置和长度来管理string，并只使用insert。

### 9.5.3节练习
<b>练习9.47</b> 编写程序，首先查找string "ab2c3d7R4E6"中的每个数字字符，然后查找其中每个字母字符。编写2个版本的程序，第1个要使用find_first_of，
第2个要使用find_first_not_of。

<b>练习9.48</b> 假定name和numbers的定义如325页所示，numbers.find(name)返回什么？

<b>练习9.49</b> 如果一个字母延申到中线之上，如d或f，则称其有上出头部分(ascender)。如果一个字母延申到中线之下，如p或g，则称其有下出头部分(descender)。
编写程序，读入一个单词文件，输出最长的既不包含上出头部分，也不包含下出头部分的单词。

### 9.5.5节练习
<b>练习9.50</b> 编写程序处理一个vector<string>，其元素都表示整型值。计算vector中所有元素之和。修改程序，使之计算表示浮点值的string之和。

<b>练习9.51</b> 设计一个类，它有3个unsigned成员，分别表示年、月、日。为其编写构造函数，接受一个表示日期的string参数。你的构造函数应该能处理不同
数据格式，如January 1, 1900、1/1/1990、Jan 1 1900等。






